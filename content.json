{"meta":{"title":"何小智の博客","subtitle":"时间是人类发展的空间。","description":"“”","author":"RenKeXZ","url":"https://hexuezhi.github.io","root":"/"},"pages":[{"title":"404","date":"2020-06-05T11:34:59.542Z","updated":"2020-01-02T14:52:29.140Z","comments":true,"path":"404.html","permalink":"https://hexuezhi.github.io/404","excerpt":"","text":""},{"title":"about","date":"2020-01-01T10:02:17.000Z","updated":"2020-06-05T11:34:25.367Z","comments":true,"path":"about/index.html","permalink":"https://hexuezhi.github.io/about/","excerpt":"","text":"If a man works only for himself, he may become a famous scholar, a brilliant intellectual, but he can never be a real perfect man."},{"title":"","date":"2020-06-05T13:21:15.800Z","updated":"2020-06-05T13:21:15.800Z","comments":false,"path":"categories/index.html","permalink":"https://hexuezhi.github.io/categories/","excerpt":"","text":""},{"title":"","date":"2020-06-08T06:57:25.323Z","updated":"2020-06-08T06:57:25.323Z","comments":false,"path":"tags/index.html","permalink":"https://hexuezhi.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"解决pip安装速度慢","slug":"解决pip安装速度慢","date":"2020-12-05T04:09:34.349Z","updated":"2020-12-05T05:08:25.899Z","comments":true,"path":"2020/12/05/解决pip安装速度慢/","link":"","permalink":"https://hexuezhi.github.io/2020/12/05/%E8%A7%A3%E5%86%B3pip%E5%AE%89%E8%A3%85%E9%80%9F%E5%BA%A6%E6%85%A2/","excerpt":"解决pip安装慢的问题。","text":"解决pip安装慢的问题。 方案：更换下载源国内的一些站点： 豆瓣：http://pypi.douban.com/simple/ 清华：https://pypi.tuna.tsinghua.edu.cn/simple 阿里云：http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学：http://pypi.hustunique.com/ 山东理工大学：http://pypi.sdutlinux.org/ 注意：地址中可能有的是https协议 方法一1pip install pymongo -i https://mirrors.aliyun.com/pypi/simple/ 方法二：永久1.ubuntu18下1gedit ~/.pip/pip.conf 修改为： 1234[global]index-url &#x3D; https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;[install]trusted-host&#x3D;mirrors.aliyun.com 2.win10下1pip config set global.index-url https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;","categories":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/categories/python/"}],"tags":[{"name":"pip","slug":"pip","permalink":"https://hexuezhi.github.io/tags/pip/"}]},{"title":"Tomcat启动startup.bat出现乱码","slug":"Tomcat启动startup.bat出现乱码","date":"2020-12-05T04:09:32.106Z","updated":"2020-12-05T05:08:40.881Z","comments":true,"path":"2020/12/05/Tomcat启动startup.bat出现乱码/","link":"","permalink":"https://hexuezhi.github.io/2020/12/05/Tomcat%E5%90%AF%E5%8A%A8startup.bat%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81/","excerpt":"解决tomcat出现乱码的问题。","text":"解决tomcat出现乱码的问题。 解决方法：找到apache-tomcat-9.0.31\\conf\\的logging.properties文件。 1java.util.logging.ConsoleHandler.encoding = UTF-8 将UTF-8，改为GBK即可。如果没有这行配置，则加上。","categories":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://hexuezhi.github.io/categories/Tomcat/"}],"tags":[{"name":"乱码","slug":"乱码","permalink":"https://hexuezhi.github.io/tags/%E4%B9%B1%E7%A0%81/"}]},{"title":"Go环境变量配置","slug":"Go环境变量配置","date":"2020-12-05T04:08:51.652Z","updated":"2020-12-05T04:54:48.039Z","comments":true,"path":"2020/12/05/Go环境变量配置/","link":"","permalink":"https://hexuezhi.github.io/2020/12/05/Go%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/","excerpt":"Go的安装和配置。","text":"Go的安装和配置。 windows下需要设置三个环境变量将三个变量设置在系统变量中即可 GOROOT; Go的安装目录，如D:\\Go GOPATH; Go项目的工作目录，如D:\\GoProject PATH; 类似JAVA,如D:\\Go\\binlinux下下载地址：https://golang.google.cn/dl/解压： 1sudo tar xf go1.14.linux-amd64.tar.gz -C /usr/local 配置环境变量： 1gedit ~/.bashrc 添加以下内容： 123export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;goexport GOPATH&#x3D;&#x2F;home&#x2F;hxz&#x2F;projectexport PATH&#x3D;$GPROOT&#x2F;bin:$PATH 测试是否安装成功： 1go version","categories":[{"name":"Go","slug":"Go","permalink":"https://hexuezhi.github.io/categories/Go/"}],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"https://hexuezhi.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"}]},{"title":"python文件操作","slug":"python文件操作","date":"2020-12-03T12:41:33.650Z","updated":"2020-12-03T12:43:56.750Z","comments":true,"path":"2020/12/03/python文件操作/","link":"","permalink":"https://hexuezhi.github.io/2020/12/03/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"折腾了一下自己的linux的shell，更换为oh-my-zsh，并更换主题,安装提示插件。 python文件操作。","text":"折腾了一下自己的linux的shell，更换为oh-my-zsh，并更换主题,安装提示插件。 python文件操作。 with open() as f:用法1. 常见用法：123456with open(r'filename.txt') as f: for l in f: l = json.loads(l) #文件的读操作with open('Hello.txt', 'w') as f: f.write('hello world') #文件的写操作 2. 先关参数： r: 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb: 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 r+: 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+:以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w: 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb: 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 w+: 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb+:以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a: 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab: 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+: 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+:以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 3. f的方法属性：123456789101112file.read([size]) #将文件数据作为字符串返回，可选参数size控制读取的字节数file.readlines([size]) #返回文件中行内容的列表，size参数可选file.write(str) #将字符串写入文件file.writelines(strings) #将字符串序列写入文件file.close() #关闭文件file.closed #表示文件已经被关闭，否则为Falsefile.mode #Access文件打开时使用的访问模式file.encoding #文件所使用的编码file.name #文件名file.newlines #未读取到行分隔符时为None，只有一种行分隔符时为一个字符串，当文件有多种类型的行结束符时，则为一个包含所有当前所遇到的行结束的列表file.softspace #为0表示在输出一数据后，要加上一个空格符，1表示不加。这个属性一般程序员用不着，由程序内部使用","categories":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/categories/python/"}],"tags":[{"name":"文件","slug":"文件","permalink":"https://hexuezhi.github.io/tags/%E6%96%87%E4%BB%B6/"}]},{"title":"题目","slug":"upload/安装ohmyzsh 1","date":"2020-11-30T12:58:26.488Z","updated":"2020-11-30T13:01:07.133Z","comments":true,"path":"2020/11/30/upload/安装ohmyzsh 1/","link":"","permalink":"https://hexuezhi.github.io/2020/11/30/upload/%E5%AE%89%E8%A3%85ohmyzsh%201/","excerpt":"前言。","text":"前言。","categories":[{"name":"分类","slug":"分类","permalink":"https://hexuezhi.github.io/categories/%E5%88%86%E7%B1%BB/"}],"tags":[{"name":"标签","slug":"标签","permalink":"https://hexuezhi.github.io/tags/%E6%A0%87%E7%AD%BE/"}]},{"title":"scrapy爬虫部署","slug":"scrapy爬虫部署","date":"2020-11-16T14:55:27.087Z","updated":"2020-12-05T05:13:29.793Z","comments":true,"path":"2020/11/16/scrapy爬虫部署/","link":"","permalink":"https://hexuezhi.github.io/2020/11/16/scrapy%E7%88%AC%E8%99%AB%E9%83%A8%E7%BD%B2/","excerpt":"学习了一下scrapy爬虫的部署，记录一下过程。","text":"学习了一下scrapy爬虫的部署，记录一下过程。 一、服务器端1 安装包1234pip3 install scrapydpip3 install scrapypip3 install scrapyd-clientpip3 install pymongo 2 修改scrapyd配置文件2.1 首先找包的安装路径1234python3&gt;&gt;import sys&gt;&gt;print(sys.path)&gt;&gt;exit() image-20201116153610363 2.2 修改scrapyd的配置文件1234cd &#x2F;home&#x2F;ethTrace&#x2F;.local&#x2F;lib&#x2F;python3.6&#x2F;site-packagesls #查看是否有scrapyd文件夹cd scrapydvim default_scrapyd.conf 将bind_address改为0.0.0.0 {% image https://i.loli.net/2020/11/16/9hMbZR7TulJcQCi.png 'image-20201116154003135' '' %} 3 启动scrapyd123#新建自己的私人项目的目录，并到自己的私人项目目录下，我这里是code&#x2F;python&#x2F;CollecAbicd ~&#x2F;hxz&#x2F;code&#x2F;python&#x2F;CollecAbinohup scrapyd &amp; 4 验证启动是否成功在这之前需要开启服务器的6800端口。如果是自己买的服务器，不光要检查防火墙端口是否开放，还需登录购买服务器的官网，检查安全组是否开放6800端口。 在本地浏览器输入http://服务器ip地址:6800，如下图所示，则表示启动成功 image-20201116154829745 二、本地1 安装包1.1 安装scrapy-client==注意==：安装scrapy-client，win10系统如果直接用pip安装可能会发生不能识别scrapy-deploy命令的错误。所以建议直接通过下载github源码安装。 源码地址，下载后解压，在文件夹下执行如下命令： 1python setup.py install 若已经用pip安装了的，先卸载Scrapyd-client 1pip uninstall scrapyd-client 1.2 安装curl下载地址，win10_64位下载如下版本。 image-20201116161250262 添加环境变量 CURL_HOME:为解压后的文件夹根目录 image-20201116161520511 Path中添加两个地址 image-20201116161617776 测试是否安装成功，在powershell中会出错，推荐用cmd。 1curl --help 2 修改项目文件夹下的scrapy.cfg文件123456[settings]default &#x3D; CollectAbi.settings[deploy:CollectAbi] #这里添加url &#x3D; http:&#x2F;&#x2F;服务器ip:6800&#x2F;project &#x3D; CollectAbi 3 部署3.1 打包在项目根目录下启用cmd，执行如下命令。一定要在CMD中运行命令，powershell中会出错 1scrapyd-deploy {% image https://i.loli.net/2020/11/15/Sj1etwknpKQlx7y.png 'image-20201115181511455' '' %} 3.2 上传1scrapyd-deploy CollectAbi -p CollectAbi image-20201115181731049 服务器端会出现两个文件夹，表示上传完成 image-20201115181924994 3.3 检查服务器运行状态1curl http:&#x2F;&#x2F;172.30.143.22:6800&#x2F;daemonstatus.json 3个0，表示没用等待和运行以及完成的爬虫任务。 {% image https://i.loli.net/2020/11/16/AiNOaBM8lxG5e7F.png 'image-20201116162152531' '' %} 4 启动爬虫1curl http:&#x2F;&#x2F;172.30.143.22:6800&#x2F;schedule.json -d project&#x3D;CollectAbi -d spider&#x3D;collectAbi 注意：spider后面跟的是文件名，不是文件夹名。 image-20201115182328977 5 停止爬虫12","categories":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/categories/python/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://hexuezhi.github.io/tags/scrapy/"}]},{"title":"typora主题","slug":"typora主题","date":"2020-10-15T16:00:00.000Z","updated":"2020-10-16T05:44:39.924Z","comments":true,"path":"2020/10/16/typora主题/","link":"","permalink":"https://hexuezhi.github.io/2020/10/16/typora%E4%B8%BB%E9%A2%98/","excerpt":"一直在用typora-theme-flora这款主题，碰巧看到原主题github上有人发了issue求黑色主题，下手改了一个。改完发现原主题有bug，也一并解决了。","text":"一直在用typora-theme-flora这款主题，碰巧看到原主题github上有人发了issue求黑色主题，下手改了一个。改完发现原主题有bug，也一并解决了。 主题下载地址：https://github.com/HeXueZhi/typora-theme-FloraDark如果可以的话请帮忙给个star，谢谢 声明：本主题是在typora-theme-flora主题基础上做的修改，在此感谢原作者wnanbei。 由来：一直在用flora这款主题，碰巧看到原主题github上有人发了issue求黑色主题，下手改了一个。改完发现原主题有bug，也一并解决了。所以本主题可以放心使用。 相比原主题的变动： 调大了字体，以及适配各种小符号。 修改了原主题的代码样式，以及一些代码选择、光标所在行背景颜色，语言选择。（原主题代码中会出现大片红色，显得很乱） 修改表格，增加分割线及表头深色显示。 在此基础上增加了黑色主题并修复了bug。 Dark Preview QQ截图20201013225453 Light Preview QQ截图20201009130648 安装方法 通过Typora的设置-&gt;主题-&gt;打开主题文件夹，来打开文件夹。 将flora文件夹、flora-hans.css以及flora-dark.css复制到typora的主题文件夹下。 重启Typora，再次进入设置-&gt;主题，就可以选择新的FloraDark主题了。","categories":[{"name":"typora","slug":"typora","permalink":"https://hexuezhi.github.io/categories/typora/"}],"tags":[]},{"title":"01背包问题","slug":"01背包问题","date":"2020-10-11T16:00:00.000Z","updated":"2020-11-07T19:44:16.196Z","comments":true,"path":"2020/10/12/01背包问题/","link":"","permalink":"https://hexuezhi.github.io/2020/10/12/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"在LeetCode上看到大神总结的01背包问题。","text":"在LeetCode上看到大神总结的01背包问题。 原链接：https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/ 一、背包问题分类1 组合问题377.组合总和Ⅳ 494.目标和 518.零钱兑换 II 2 True、False问题。139.单词拆分 416.分割等和子集 3 最大最小问题474.一和零 322.零钱兑换 二、背包问题状态转移公式1 组合问题公式1dp[i] +&#x3D; dp[i-num] 2 True、False问题公式1dp[i] &#x3D; dp[i] or dp[i-num] 3 最大最小问题公式1dp[i] &#x3D; min(dp[i], dp[i-num]+1)或者dp[i] &#x3D; max(dp[i], dp[i-num]+1) 三、解题步骤 分析是否为背包问题。 是以上三种背包问题中的哪一种。 是0-1背包问题还是完全背包问题。也就是题目给的nums数组中的元素是否可以重复使用。 如果是组合问题，是否需要考虑元素之间的顺序。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法。 四、背包问题的判定背包问题具备的特征： 给定一个target，target可以是数字也可以是字符串，再给定一个数组nums，nums中装的可能是数字，也可能是字符串，问：能否使用nums中的元素做各种排列组合得到target。 背包问题技巧： 如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序； 12for num in nums: for i in range(target, nums-1, -1): 如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。 12for num in nums: for i in range(nums, target+1): 如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。 12for i in range(1, target+1): for num in nums:","categories":[{"name":"算法","slug":"算法","permalink":"https://hexuezhi.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"01背包问题","slug":"01背包问题","permalink":"https://hexuezhi.github.io/tags/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"}]},{"title":"Java刷题笔记","slug":"java刷题笔记","date":"2020-09-23T16:00:00.000Z","updated":"2020-11-30T13:33:32.227Z","comments":true,"path":"2020/09/24/java刷题笔记/","link":"","permalink":"https://hexuezhi.github.io/2020/09/24/java%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 一、集合1 数组1.1 新建数组1int[] a = new int[5]; 1.2 数组大小1a.length 1.3 数组排序12Arrays.sort(a);//升序排列数组Arrays.sort(a, 1, 5);//对index从1到4的元素做升序排列 自定义排序规则： 1234567int[][] b = new int[4][2];Arrays.sort(b, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0]==o2[0] ? o1[1]-o2[1] : o2[0]-o1[0]; &#125;&#125;) 1.4 数组复制1Arrays.copyOfRange(array,0,array.length);//左闭右开 2 List2.1 新建List1List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); 2.2 添加元素12nums.add(3);//尾部添加3nums.add(0,3);//index=0处，添加3 2.3 获取元素1int n = nums.get(0);//index 2.4 删除元素1nums.remove(0);//删除第一个元素 2.5 是否为空1nums.isEmpty() 2.6 是否包含元素1nums.contains(3); 2.7 列表长度1nums.size() 2.8 清空列表1nums.clear() 2.9 反转列表12List&lt;Integer&gt; nums = new ArrayList&lt;&gt;();Collections.reverse(nums); 2.10 List转为Array数组1234567List&lt;String&gt; strList = new ArrayList&lt;String&gt;();strList.add(\"list\");strList.add(\"to\");strList.add(\"array\");String[] strArray = new String[strList.size()];strList.toArray(strArray);//括号里的数组，为想要的结果数组的形式strList.toArray(new String[strList.size()]); 2.11 Array数组转为List12String[] strArray = new String[]&#123;\"array\", \"to\", \"list\"&#125;;List&lt;String&gt; strList = Arrays.asList(strArray); 2.12 List合并1list1.addAll(list2); 2.13 List排序12345678Collection.sort(list);//从小到大Collection.sort(list,Collections.reverseOrder());//从大到小//自定义Collection.sort(list,new Comparator&lt;Point&gt;()&#123; public int compare(Point a,Point b)&#123; return a.get(x)==b.get(x)?a.get(y)-b.get(y):a.get(x)-b.get(x); &#125;&#125;); 3 Set3.1 新建集合1Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); 3.1 添加元素1set.add(1); 3.2 删除元素1set.remove(2);//这里只能删除元素，无index 3.3 是否包含1set.contains(5); 3.4 遍历123for(Integer i:set)&#123; System.out.println();&#125; 4 HashMap4.1 新建HashMap1HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(); 4.2 添加键值对1map.put(\"zhang\", \"31\"); 4.3 获取键值对1map.get(\"zhang\"); 4.4 是否包含12map.containsKey(\"zhang\");map.containsValue(\"31\"); 4.5 删除键值对12map.remove(\"zhang\");map.remove(\"zhang\",\"31\");//Removes the entry for the specified key only if it is currently mapped to the specified value. 4.6 返回key Set1map.keySet(); 4.7 返回value Colleciton1map.values(); 4.8 遍历HashMap1234Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();for (String key : map.keySet()) &#123; map.get(key);&#125; 4.9 getOrDefault1map.put(str, map.getOrDefault(str, 0) + 1);//如果存在就+1，不存在就为0 5 Stack官方不推荐使用Stack类，推荐使用Deque。 5.1 新建栈1Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); 5.2 添加元素1stack.push(3); 5.3 弹出元素1stack.pop(); 5.4 获取栈顶元素1stack.peek(); 6 queue6.1 新建队列1ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;(); 6.2 添加元素12deque.add(3);//尾部添加3deque.addFirst(3);//头部添加3 6.3 获取元素12duque.getFirst();deque.getLast(); 6.4 获取并删除12deque.pollFirst();//出队deque.pollLast();//弹栈 7 PriorityQueue7.1 新建堆1PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(); 7.2 添加元素1pq.add(3); 7.3 获取元素12pq.peek();//不删除元素pq.poll();//删除元素 7.4 删除元素1pq.remove(3); 7.5 转为数组1pq.toArray(); 8 Deque双端队列，控制每一端元素的进出，可以实现栈或者队列。 8.1 实例化12Deque&lt;Integer&gt; deque = mew ArrayDeque&lt;&gt;();Deque&lt;Integer&gt; deque = enw LinkedList&lt;&gt;(); 8.2 添加元素到队尾12addLast(E e) offerLast(E e) 8.3 取队尾元素并删除12E removeLast()E pollLast() 8.4 取队尾元素并不删除12E getLast()E peekLast() 8.5 添加元素到队首12addFirst(E e)offerFirst(E e) 8.6 取队首元素并删除12E removeFirst()E pollFirst() 8.7 取队首元素并不删除12E getFirst()E peekFirst() 二、杂项1 三元运算符1int a = node==null ? 0 : node.val; 2 Math1234int a = Math.max(2,3);int a = Math.sqrt(4);//开根号int a = Math.abs(-1);//取绝对值int a = Math.pow(2,3);//2的3次方 3 最大值、最小值表示12int a = Integer.MAX_VALUEint b = Integer.MIN_VALUE 4 Arrays123Arrays.sort(a);//排序int[] aArrays.fill(a,Integer.MAX_VALUE);//快速向a中填充最大值Arrays.copyOf(nums,nums.length);//复制数组 5 位运算位运算后，需要重新赋值 123456a = a &amp; 1;//判断a是不是基数a = a | 1;a = ~a;a = a ^ 1;//异或运算a = a &lt;&lt; 1;//左移一位a = a &gt;&gt; 1;//右移一位 6 转换6.1 char转int12char ch = 'x';int x = 'x' - 'a'; 6.2 int转char1char ch = (char)(num + 'a'); 6.3 char转String1String s = String.valueOf(ch); 6.4 char[]转Stirng1234char[] chs = new char[n];String s = new String(chs);//或者String s = String.valueOf(chs) 6.5 String转char1s.charAt(i); 6.6 String转char[]1s.toCharArray() 7 flag取反1flag = !flag; 8 随机数12Random rand = new Random();rand.nextInt(n);//[0,n)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://hexuezhi.github.io/categories/leetcode/"}],"tags":[{"name":"java","slug":"java","permalink":"https://hexuezhi.github.io/tags/java/"}]},{"title":"oh-my-zsh安装及主题更换","slug":"安装ohmyzsh","date":"2020-09-14T13:48:47.277Z","updated":"2020-09-27T11:35:34.977Z","comments":true,"path":"2020/09/14/安装ohmyzsh/","link":"","permalink":"https://hexuezhi.github.io/2020/09/14/%E5%AE%89%E8%A3%85ohmyzsh/","excerpt":"折腾了一下自己的linux的shell，更换为oh-my-zsh，并更换主题,安装提示插件。","text":"折腾了一下自己的linux的shell，更换为oh-my-zsh，并更换主题,安装提示插件。 最终效果： new UI 1 安装1234567yum install gityum install zsh#方案一：sh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh --no-check-certificate -O -)\"#方案二：（官方方案）sh -c \"$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 2 更换主题1234cd ~/.oh-my-zsh/themes &amp;&amp; lsvim ~/.zshrc#ZSH_THEME=\"agnoster\"source ~/.zshrc 3 安装插件（zsh-autosuggestions）12345git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestionsvim ~/.zshrc#将zsh-autosuggestions添加到plugins中#plugins=(git zsh-autosuggestions)source ~/.zshrc","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/categories/CentOS/"}],"tags":[{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://hexuezhi.github.io/tags/oh-my-zsh/"}]},{"title":"获取用户任务列表报500BUG","slug":"用户任务列表报500BUG","date":"2020-09-04T07:05:19.444Z","updated":"2020-11-27T10:49:41.876Z","comments":true,"path":"2020/09/04/用户任务列表报500BUG/","link":"","permalink":"https://hexuezhi.github.io/2020/09/04/%E7%94%A8%E6%88%B7%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%E6%8A%A5500BUG/","excerpt":"公司人员报告了获取任务列表为500的bug，但是我们测试数据却能正常返回。玄学？NO!NO!NO!","text":"公司人员报告了获取任务列表为500的bug，但是我们测试数据却能正常返回。玄学？NO!NO!NO! BUG情况公司人员报告了一个bug，获取我们用户任务列表的接口数据时会出现500的异常。但是经过我们自己测试没有发现问题。 几天后，公司人员又发来了截图，表示获取任务列表又出现了500异常。并且测试过后发现只有userid是6的才会出现500异常，其他userid不会出现，并且userid为6的用户调用这个接口，时而能够正常返回数据，时而又出现500bug。 原因经过查看项目log发现程序运行过程中出现了空指针异常。并且定位到相关的代码行。 1long sl = user.getFinishTime().getTime() - user.getCreateTime().getTime(); （不要问为什么任务的变量名是user，我也不知道。。。）小伙伴写这段代码时是通过获取到任务的finishTime，再拿finishTime减去createTime。 初步猜想可能是新创建的任务没有finish，导致获取到的finishTime为null。因此引发空指针异常。 而当用户的任务完成时，finishTime被填上，再获取任务列表时，又可以正常获取到数据。 又因为公司那边测试一直用的是同一个用户id（6），所以每次创建任务之后获取任务列表，显示是500.其他用户id并没有运行任务，所以表象是只有userid为6的用户才会发生异常。 进一步查看log，佐证了自己的猜想。 500bug log显示在查询用户列表之前，用户新创建了一个任务。 总结虽问题不是什么大问题，代码也不是自己写的，但有两点须引以为戒。 变量名的规范：任务记录的对象，命名为user，让我在定位bug的时候，理解代码出现了偏差。所以变量命名规范，有助于对代码快速的理解，从而能够更快的定位bug。 注释：太重要了！！！如果不写注释，等出现bug再定位的时候，再次读即使是自己写的代码，也会耗费些时间来理解。","categories":[{"name":"bug","slug":"bug","permalink":"https://hexuezhi.github.io/categories/bug/"}],"tags":[{"name":"bug","slug":"bug","permalink":"https://hexuezhi.github.io/tags/bug/"}]},{"title":"docker部署nginx+tomcat","slug":"docker部署nginx+tomcat","date":"2020-09-03T13:10:08.815Z","updated":"2020-09-05T12:33:38.941Z","comments":true,"path":"2020/09/03/docker部署nginx+tomcat/","link":"","permalink":"https://hexuezhi.github.io/2020/09/03/docker%E9%83%A8%E7%BD%B2nginx+tomcat/","excerpt":"以docker方式启动tomcat+nginx。","text":"以docker方式启动tomcat+nginx。 一、tomcat新建tomcat文件夹，可以放入自己的应用。 1234567mkdir tomcatcd tomcatmkdir appcd apptouch index.htmlecho &lt;h1&gt;helloworld&lt;/h1&gt; &gt;index.htmlcd .. 拉取镜像，并建立开启容器(注意这里并不用开启8080端口映射)： 12docker pull tomcatdockers run -id --name myTomcat -v $PWD:/usr/local/tomcat/webapps tomcat 查看容器ip： 1docker inspect myTomcat | grep \"IPAddress\" 假设这里查到的是172.17.0.3 二、nginx首先服务器防火墙开启80端口： 12firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --reload 新建nginx文件夹，并新建nginx.conf 1234mkdir nginxcd nginxtouch nginx.confvim nginx.comf 填入nginx.conf的内容，注意http-&gt;server-&gt;location-&gt;proxy_pass。修改为上一步查到的ip。 注意：这里不能填入宿主机的ip。（因为tomcat默认并不是以host模式开启，而是以桥接模式开启） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; location / &#123; root html; proxy_pass http://172.17.0.3:8080; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 拉取镜像，并建立开启容器： 12docker pull nginxdocker run -d --name myNginx -p 80:80 nginx 将之前写的配置文件复制到容器中，并重启容器： 12docker cp nginx.conf nginx:/etc/nginx/nginx.confdocker restart nginx 三、测试访问http://服务器ip/app","categories":[{"name":"以太坊","slug":"以太坊","permalink":"https://hexuezhi.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hexuezhi.github.io/tags/docker/"},{"name":"tomcat","slug":"tomcat","permalink":"https://hexuezhi.github.io/tags/tomcat/"},{"name":"nginx","slug":"nginx","permalink":"https://hexuezhi.github.io/tags/nginx/"}]},{"title":"docker启动以太坊私链","slug":"docker启动以太坊私链","date":"2020-09-01T12:27:08.059Z","updated":"2020-10-08T16:26:39.888Z","comments":true,"path":"2020/09/01/docker启动以太坊私链/","link":"","permalink":"https://hexuezhi.github.io/2020/09/01/docker%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/","excerpt":"以docker方式启动以太坊私链，并部署Dapp。","text":"以docker方式启动以太坊私链，并部署Dapp。 一、查看防火墙状态首先查看主机防火墙是否开启，如果已开启，需要开放8545端口，用于外界通过rpc方式访问私链。 查看防火墙状态： 1systemctl status firewalld.service {% image https://i.loli.net/2020/09/01/wJPvbiOChzE9VGx.png '防火墙状态' '' %} 开放方法： 12firewall-cmd --zone=public --add-port=8545/tcp --permanentfirewall-cmd --reload 二、创建链码在workspace下，新建/code/chain/mychain文件夹，创建genesis.json。 路径 chainId：以太坊的链的id，可以自己随便取值，但是需要注意搭建私链时，这个值不能与以太坊主网或者是测试网的chainId相同。以太坊chainId查询 genesis.json： 123456789101112131415161718192021222324252627&#123; &quot;config&quot;: &#123; &quot;chainId&quot;: 666, &quot;homesteadBlock&quot;: 0, &quot;eip150Block&quot;: 0, &quot;eip150Hash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;eip155Block&quot;: 0, &quot;eip158Block&quot;: 0, &quot;byzantiumBlock&quot;: 0, &quot;constantinopleBlock&quot;: 0, &quot;petersburgBlock&quot;: 0, &quot;istanbulBlock&quot;: 0, &quot;ethash&quot;: &#123;&#125; &#125;, &quot;nonce&quot;: &quot;0x0&quot;, &quot;timestamp&quot;: &quot;0x5ddf8f3e&quot;, &quot;extraData&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;gasLimit&quot;: &quot;0x47b760&quot;, &quot;difficulty&quot;: &quot;0x00002&quot;, &quot;mixHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;, &quot;alloc&quot;: &#123; &#125; &#125;, &quot;number&quot;: &quot;0x0&quot;, &quot;gasUsed&quot;: &quot;0x0&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&#125; 三、拉取image1docker pull ethereum/client-go 四、创建容器123docker run -it --network=host --name mychain -v /workspace:/workspace --entrypoint /bin/sh ethereum/client-go#或者docker run -it --name mychain -p 8545:8545 -v /workspace:/workspace --entrypoint /bin/sh ethereum/client-go 参数说明： -i：打开STDIN，用于控制台交互，常与-t一起使用 -t：分配tty设备，支持终端登陆，默认为false，常与-i一起使用 --network=host：将容器的网络模式设置为host模式，即用宿主机的ip和端口进行外部通信 -p 8545:8545：将宿主机的8545端口映射到dockers容器的8545端口上 --rm：指定容器停止后自动删除容器（不支持以docker run -d启动的容器 ） -v：给容器挂载存储卷，挂载到容器的某个目录，这里讲本地的/workspace挂载到了容器的/workspace目录，用来在容器和宿主机之间共享文件 --entrypoint：覆盖image的入口点，ubuntu环境下docker默认入口点其实是/bin/bash，修改默认入口点是为了不让节点自动运行，稍后会对节点进行自定义配置使其成为私有链节点 此后启动容器就可以，直接通过 1docker start -i mychain 五、启动私链经过上面的命令，此时命令行提示符已经转变。进入之前创建的/workspace/code/chain/mychain文件夹下，初始化链json 1geth --datadir . init genesis.json 启动私链，networkid和rpcaddr的设置方法同开发者模式。查看输出日志output.log同上。 1geth --datadir . --nodiscover --networkid 1234 --rpc --rpccorsdomain &quot;*&quot; --rpcaddr 0.0.0.0 --rpcport 8545 console --allow-insecure-unlock 2&gt;output.log 注意：搭建私链后一定要进行以下测试，看是否能够正常发起交易。","categories":[{"name":"以太坊","slug":"以太坊","permalink":"https://hexuezhi.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hexuezhi.github.io/tags/docker/"}]},{"title":"以太坊合约交易inputData解码","slug":"以太坊合约交易inputData解码","date":"2020-09-01T02:20:24.016Z","updated":"2020-11-26T05:28:45.958Z","comments":true,"path":"2020/09/01/以太坊合约交易inputData解码/","link":"","permalink":"https://hexuezhi.github.io/2020/09/01/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%90%88%E7%BA%A6%E4%BA%A4%E6%98%93inputData%E8%A7%A3%E7%A0%81/","excerpt":"以太坊每笔交易中都有InputData，本项目主要是识别合约交易中的InputData。","text":"以太坊每笔交易中都有InputData，本项目主要是识别合约交易中的InputData。 一、需求式例交易hash：0xb1c0abd217193ffe64f97caedad8fa6f0f9c0265967d2ab9fb782280c928fb47 inputdata 需要将交易中的数据解码为上图中的数据。 二、思路 先通过web3来取得交易中的to地址和inputdata。 将to地址传入erherScan的api获得合约的abi。 通过abi-decoder来解析inputdata。 三、具体实现项目地址：https://github.com/HeXueZhi/DecodeInputData 整体通过webpack框架。应用的包：package.json文件中的dependencies 3.1 实例化web3在infura注册一个key，替换代码中的key。（Infura提供免费的以太坊节点RPC API服务） 1234567891011121314151617181920212223window.addEventListener('load', function() &#123; if (typeof web3 !== 'undefined') &#123; window.web3 = new Web3(web3.currentProvider); &#125; else &#123; var web3Provider; if (window.ethereum) &#123; web3Provider = window.ethereum; try &#123; // 请求用户授权 window.ethereum.enable(); &#125; catch (error) &#123; // 用户不授权时 console.error(\"User denied account access\") &#125; &#125; else if (window.web3) &#123; // 老版 MetaMask Legacy dapp browsers... web3Provider = window.web3.currentProvider; &#125; else &#123; web3Provider = new Web3.providers.HttpProvider('https://mainnet.infura.io/v3/填入infura个人的key'); &#125; web3 = new Web3(web3Provider); &#125; // App.start();&#125;); 3.2 解析inputdata在etherscan注册apikey，替换代码中的。 如果不想注册删掉代码中的&amp;apikey=填入etherscan的个人key也可以，不过etherscan会添加每秒限制访问5次的限制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import \"./app.css\";import &#123; default as Web3&#125; from 'web3';var web3;var ABI;const fetch = require('node-fetch');//通过fetch获取abiconst abiDecoder = require('abi-decoder'); // 通过abi解析inputdatawindow.App = &#123; getInputData: function()&#123; document.getElementById(\"textArea\").value = \"\"; document.getElementById(\"textArea2\").value = \"\"; var TXHash = document.getElementById(\"TXHash\").value; if (TXHash != null)&#123; console.log(TXHash); var inputData; web3.eth.getTransaction(TXHash,function(err, accs) &#123; if (err != null) &#123; alert(\"There was an error fetching your TX.\"); return; &#125; if (accs.length == 0) &#123; alert(\"Couldn't get any accounts! Make sure your Ethereum client is configured correctly.\"); return; &#125; console.log(accs.input);//输出inputdata //验证to地址是否是合约地址，合约地址的Code不为空 web3.eth.getCode(accs.to, function(err, accs)&#123; if(accs === '0x') &#123; alert('普通转账交易'); return; &#125; &#125;); var contractAddress = accs.to; if (contractAddress != null)&#123; var url = 'https://api-cn.etherscan.com/api?module=contract&amp;action=getabi&amp;address=' + contractAddress + '&amp;apikey=填入etherscan的个人key'; fetch(url, &#123;method: 'get',&#125;).then(response =&gt; response.json().then(data =&gt; &#123; ABI = JSON.parse(data.result);//获取合约abi' // console.log(ABI); document.getElementById(\"textArea\").value = JSON.stringify(JSON.parse(data.result),null, ' '); abiDecoder.addABI(ABI);//解析abi var decodedData = abiDecoder.decodeMethod(accs.input);//获得解析数据 document.getElementById(\"textArea2\").value = JSON.stringify(decodedData,null,' '); &#125;)); &#125;else&#123; alert(\"error: ContractAddress为null!!!\"); return; &#125; &#125;); &#125;else&#123; alert(\"error: TXHash为null!!!\"); return; &#125; &#125;&#125;; 3.3 build项目在文件夹下执行: 1npm run build 3.4 启动项目在文件夹下执行: 1npm run dev 访问http://localhost:8080即可。 项目截图","categories":[{"name":"以太坊","slug":"以太坊","permalink":"https://hexuezhi.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"以太坊","slug":"以太坊","permalink":"https://hexuezhi.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"inputData","slug":"inputData","permalink":"https://hexuezhi.github.io/tags/inputData/"}]},{"title":"基于以太坊私链的溯源Dapp","slug":"以太坊溯源Dapp","date":"2020-08-15T09:58:10.027Z","updated":"2020-10-08T16:28:23.266Z","comments":true,"path":"2020/08/15/以太坊溯源Dapp/","link":"","permalink":"https://hexuezhi.github.io/2020/08/15/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%AF%E6%BA%90Dapp/","excerpt":"帮助老师撰写以太坊课程的实验指导书，因此需要设计一个基于以太坊私链的溯源Dapp项目。","text":"帮助老师撰写以太坊课程的实验指导书，因此需要设计一个基于以太坊私链的溯源Dapp项目。 项目源码：https://github.com/HeXueZhi/FoodTransportation 实验环境： win10：用于创建Dapp CentOS7：用于搭建私链 一、私链的创建前面的文章有写如何搭建私链。 以太坊搭建私链 二、以太坊Dapp的创建Dapp整体基于truffle，前端采用webpack打包。 2.1 编写合约合约编写以及编译采用remix（需要较好的网络环境），推荐使用老版本界面。remix入门 合约代码： 12345678910111213141516171819202122232425262728293031323334353637pragma solidity &gt;&#x3D;0.4.22 &lt;0.7.0;contract FoodTransportation&#123; struct Location&#123; string locationName; string transPerson; uint timeStamp; &#125; string foodName; mapping (uint &#x3D;&gt; Location) trail; uint8 locationNum; function addNewLocation(string memory food,string memory locationName,string memory transPerson)public&#123; if(bytes(foodName).length &#x3D;&#x3D; 0)&#123; foodName &#x3D; food; &#125; Location memory newLocation; newLocation.locationName &#x3D; locationName; newLocation.transPerson &#x3D; transPerson; newLocation.timeStamp &#x3D; now; trail[locationNum] &#x3D; newLocation; locationNum++; &#125; function getLocationNum() public view returns(uint8)&#123; return locationNum; &#125; function getFoodName() public view returns(string memory)&#123; return foodName; &#125; function getLocation(uint8 locationNo) public view returns(string memory,string memory,uint)&#123; return (trail[locationNo].locationName,trail[locationNo].transPerson,trail[locationNo].timeStamp); &#125;&#125; 这一步需要完成合约的编译和测试。 2.2 环境准备win10系统中，安装node、truffle、ganache-cli。 执行truffle version查看版本。 {% image https://i.loli.net/2020/08/15/9PmGtVHWqx5iZhc.png 'truffle version' '' %} 尤其需要注意solidity和web3的版本。版本不同语法支持也不同，所以安装时，尽量选择于上图中相差不多的版本。 2.3 truffle+webpack创建项目 新建Dapp/FoodTransportation文件夹 文件夹下执行： 1truffle unbox webpack 此命令会下载truffle提供的官方示例，下载时间可能会有点长，耐心等待。下载完成后的提示以及目录结构如下图所示。 此示例项目的运行启动：留个坑。 修改truffle-config.js为： 12345678910require('babel-register')module.exports = &#123; networks: &#123; development: &#123; host: 'localhost', port: 8545, network_id: '*' // Match any network id &#125; &#125;&#125; 本文件夹下的powershell中执行： 1npm install babel-register 删除contracts文件夹中的ConvertLib.sol和MetaCoin.sol文件，创建FoodTransportation.sol合约文件，复制刚才编写的合约代码。 修改migrations文件夹中的2_deploy_contracts.js文件。 注意：这里直接删除这个文件也无妨，因为本项目使用web3来部署合约，不需要使用truffle migrate命令帮助部署合约。 12345const FoodTransportation = artifacts.require(\"./FoodTransportation\");module.exports = function(deployer) &#123; deployer.deploy(FoodTransportation);&#125;; powershell中执行truffle compile命令。truffle中自带的solc-js会对合约进行编译。在Dapp文件夹下会出现build文件夹，存放编译形成的json文件。 在Dapp的app文件夹下粘贴写好的html文件，src目录下粘贴需要的js文件和css文件。 修改webpack-config.js 1234567891011121314151617181920212223242526272829303132333435const path = require('path');const CopyWebpackPlugin = require('copy-webpack-plugin');module.exports = &#123; entry: './src/app.js', output: &#123; path: path.resolve(__dirname, 'build'), filename: 'app.js' &#125;, mode : 'development', plugins: [ // Copy our app's index.html to the build folder. new CopyWebpackPlugin([ &#123; from: './index.html', to: \"index.html\" &#125; ]) ], module: &#123; rules: [ &#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, &#123; test: /\\.json$/, exclude: /(node_modules|bower_components)/, use: 'json-loader' &#125;, &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, loader: 'babel-loader', query: &#123; presets: ['es2015'], plugins: ['transform-runtime'] &#125; &#125; ] &#125;&#125; 在app目录下执行： 12345678npm install web3@0.18.4 --save-devnpm install webpack --save-devnpm install style-loader css-loader json-loader --save-devnpm install -D babel-loader@7 babel-core babel-preset-env --save-devnpm install babel-preset-es2015 --save-devnpm install babel-plugin-transform-runtime --save-devnpm run buildnpm run dev 进入http://localhost:8080查看界面。注意：现在如果没有启动私链，页面由于没有获取到账户，会发出警告，启动私链，连接metamask刷新即可。 三、合约部署3.1 win10本地ganache测试 安装ganache-cli 1npm install -g ganache-cli 执行ganache-cli 在谷歌浏览器中安装metamask插件，安装好后，先在metamask右上角选择localhost:8545网络，然后选择助记词恢复钱包账户。 然后在Dapp/app执行npm run dev，打开浏览器的http://localhost:8080/ 按F12，查看console界面。 测试项目。 3.2 CentOS私链测试 开启私链，如无账户，先创建账户personal.newAccount()，输入密码。 开始挖矿。miner.start(1) 查看账户余额eth.getBalance(eth.accounts[0])，为了保证能够发起合约部署等交易，需要一些ETH。 设置虚拟机防火墙，打开8545端口。CentOS设置防火墙 metamask连接CentOS的私链。需要新创建rpc网络。 rpc地址：http://192.168.2.151:8545，ip填虚拟机ip就可以。 chainID：填入genesis.json中的chainid即可。 切换至刚创建的网络，并导入账户。通过虚拟机私链文件夹下的keystore文件夹下的json文件导入到metamask即可。 导入账户之后刷新http://localhost:8080，再点击metamask，就能够连接刚刚导入的账户了。 项目截图 测试项目。 测试完成后执行miner.stop()停止挖矿。","categories":[{"name":"以太坊","slug":"以太坊","permalink":"https://hexuezhi.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"以太坊","slug":"以太坊","permalink":"https://hexuezhi.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"Dapp","slug":"Dapp","permalink":"https://hexuezhi.github.io/tags/Dapp/"},{"name":"truffle","slug":"truffle","permalink":"https://hexuezhi.github.io/tags/truffle/"}]},{"title":"近期面试经验总结","slug":"近期面试经验总结","date":"2020-07-19T02:22:17.131Z","updated":"2020-11-25T15:40:38.306Z","comments":true,"path":"2020/07/19/近期面试经验总结/","link":"","permalink":"https://hexuezhi.github.io/2020/07/19/%E8%BF%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/","excerpt":"近期面试了几个后端岗位，记录一下面试得出的经验。","text":"近期面试了几个后端岗位，记录一下面试得出的经验。 一、面试中的问题1.问简历上的项目大体来说就是会照着简历上写的项目来进行提问。首先，就是项目的总体框架，涉及到的技术栈。会对涉及到的知识进行提问。 其次，在项目中的具体工作，就是你负责了哪一部分。项目中遇到的困难，以及如何解决的。 最后，面试官问这些一个是测试你的技术掌握的深度，再一个就是看看你对技术的热情程度。所以需要在这个过程中体现出来自己对技术的热枕。 2.操作系统相关 进程管理 内存管理 死锁相关 3.计算机网络相关 http https http2.0 osi和tcp/ip网络模型 Tcp三次握手，四次挥手。这里不仅要知道怎么握手，还要知道为什么是三次和四次 cookie和session 从输入网址到显示页面，发生了什么 4.mysql相关 事务 定义及四个特征 隔离级别 innodb和myisam存储引擎 脏读，不可重复度和幻读 索引 索引的类型 匹配原则 底层数据结构：B+树 5.java5.1 java集合 hashmap arrayList 5.2 JVM 内存机构 垃圾回收机制 5.3 多线程 hashmap、hashtable、CurrentHashMap 锁 二、面试经验1.算法方面首先，要弄清楚面试官的需求。以及一些题目的要求。所以第一步是一定不要马上写代码！！！拿到题目要问清楚面试官的具体要求，然后把自己的具体思路讲述给面试官。思路得到面试官肯定后，再写代码。 其次，在写代码的过程中，一定要注意程序的鲁棒性。特别要考虑一些空值和边界值的情况 最后，面试官出的题目可能是连环题，在你写完代码之后，会问你写的程序的时间复杂度和空间复杂度。然后再问你优化方案。 2.项目经历方面首先一个明确你在项目中的工作，然后是技术难点和解决方案，也有可能是技术亮点。 这类问题回答过程中一定要体现自己对于技术的热情。 3.基础知识方面第一种就是单纯问你的基础知识，这方面理解的基础上记忆就好了。 第二种就比较复杂。面试官会结合具体的实际业务场景来对基础知识进行提问。这一块要求对知识的掌握程度更加深刻。","categories":[{"name":"面经","slug":"面经","permalink":"https://hexuezhi.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://hexuezhi.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"字节跳动懂车帝后端面经","slug":"字节跳动懂车帝后端面经","date":"2020-07-17T12:45:07.499Z","updated":"2020-10-01T04:55:24.533Z","comments":true,"path":"2020/07/17/字节跳动懂车帝后端面经/","link":"","permalink":"https://hexuezhi.github.io/2020/07/17/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%87%82%E8%BD%A6%E5%B8%9D%E5%90%8E%E7%AB%AF%E9%9D%A2%E7%BB%8F/","excerpt":"找了学长内推了字节跳动懂车帝的后端岗位，这也是作者本人的第一次面试，有纪念意义，所以记录一下过程。","text":"找了学长内推了字节跳动懂车帝的后端岗位，这也是作者本人的第一次面试，有纪念意义，所以记录一下过程。 懂车帝后端主要用Go和python语言，因此相对来说就会少问一些java方面的知识。 面试的平台是在牛客网上，上来先做了一个简短的自我介绍，然后就直接开始问问题了。 问题1、从长度未知的链表中随机取出一个数。首先，需要说明这是一个经典的问题，需要用蓄水池抽样算法。但是本人当时并不知道这个算法。因此想出了两个方案，但是面试官都说不对，因此最后在面试官的提示下需要回去看看蓄水池算法。 错误方法1：先获取链表的长度，然后取链表长度的随机数，再取相应随机数位置的数。 面试官说不能获取链表的长度。 错误方法2：先生成一个随机数，然后取随机数位置上的链表上的数。会出现两种情况，一种是数到相应的位置上有数，直接取。第二种情况，向后遍历链表直到链表尾，发现随机数大于链表长度，这时候用随机数对链表长度取余数。取余数位置上的数。 面试官说还是需要获取到链表的长度。WTF？向后遍历到链表的尾部的同时就能够记录到链表的长度的啊。 正确答案：蓄水池取水算法 前提：给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。（这里面试官没有说出来只能够遍历一次链表）。本题面试官提出的是取一个数据，因此把m设置为1即可。 算法思路大致如下： 如果接收的数据量小于m，则依次放入蓄水池。 当遍历到第i个数据时，i &gt;= m，在[0, i]范围内取以随机数d，若d的落在[0, m-1]范围内，则用这第i个数据替换蓄水池中的第d个数据。 重复步骤2。 算法随机性的证明： 第i个数据最后能够留在蓄水池中的概率=第i个数据进入过蓄水池的概率*第i个数据不被替换的概率（第i+1到第N次处理数据都不会被替换）。 当i&lt;=m时，数据直接放进蓄水池，所以第i个数据进入过蓄水池的概率=1。 当i&gt;m时，在[1,i]内选取随机数d，如果d&lt;=m，则使用第i个数据替换蓄水池中第d个数据，因此第i个数据进入蓄水池的概率=m/i。 当i&lt;=m时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为m/(m+1)，会替换掉第i个数据的概率为1/m，则第m+1次处理替换掉第i个数据的概率为(m/(m+1))*(1/m)=1/(m+1)，不被替换的概率为1-1/(m+1)=m/(m+1)。依次，第m+2次处理不替换掉第i个数据概率为(m+1)/(m+2)…第N次处理不替换掉第i个数据的概率为(N-1)/N。所以，之后第i个数据不被替换的概率=m/(m+1)*(m+1)/(m+2)*...*(N-1)/N=m/N。（这里如果m==1，表示只取一个数据，因此概率为1/N） 当i&gt;m时，程序从接收到第i+1个数据时开始有可能替换第i个数据。则参考上述第3点，之后第i个数据不被替换的概率=i/N。 结合第1点和第3点可知，当i&lt;=m时，第i个接收到的数据最后留在蓄水池中的概率=1*m/N=m/N。结合第2点和第4点可知，当i&gt;m时，第i个接收到的数据留在蓄水池中的概率=m/i*i/N=m/N。综上可知，每个数据最后被选中留在蓄水池中的概率为m/N。 这个算法建立在统计学基础上，很巧妙地获得了&quot;m/N&quot;这个概率。 问题2、写一个斐波那契数列。给n求n位置上的值0、1、1、2、3、5…… 123456def fib(n): if n == 0: return 0 if n == 1: return 1 return fib(n-1)+fib(n-2) 问题3、斐波那契数列递归算法的时间空间复杂度，以及如何优化时间复杂度O（n） 空间复杂度O（n） 优化采用自底向下的动态规划算法。 12345def fib(n): res = [0,1] for i in range(2,n+1): res.append(res[-1]+res[-2]) return res[n] 这种算法需要空间空间复杂度为O(n),可以再优化为常数级别。 12345678def fib(n): num1 = 0 num2 = 1 if n == 0: return num1 for i in range(2,n+1): num1,num2 = num2,num1+num2 return num2 说起来惭愧，这是《剑指offer》上的原题，面试之前作者并没有读过，当时又非常紧张，没有写出来这道题。面完试感觉这道题是easy的。 问题4.操作系统什么时候会从用户态进入到内核态内核态主要涉及到一些特权指令的操作。发生系统调用时会从用户态转移到内核态。 系统调用： 设备管理 文件管理 进程控制 进程通信 内存管理 问题5.Tcp拥塞控制 慢开始 拥塞避免 快重传 快恢复 慢开始：指数增长就是将拥塞窗口cwnd设置为1，没经过一个RTT，cwnd加倍，指数增长。知道到达满开始门限阈值采用拥塞避免算法。 拥塞避免：线性zeng’zhang每经过一个RTT就增加一个MSS大小。知道出现第一次超时（网络拥塞），就将慢开始门限设置为此时拥塞窗口值的一半。然后把cwnd重置为1。执行慢开始算法。 快重传：当发送方接收到3个冗余ACK时，就认为确认的报文后面的报文段丢失了。并立即对缺失的报文段重传。 快恢复：就是发生冗余ACK时间时候，将慢开始门限设置为当前的一半，然后将cwnd设置慢开始门限值，开始拥塞避免算法。 问题6.进程通信方式 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 问题7.Tcp连接三次握手，为什么不是两次 tcp三次握手 第一次握手：客户机向服务器发送连接请求报文。 第二次握手：服务器的TCP收到连接请求报文之后，同意链接，向客户机发回确认，为TCP连接分配TCP缓存和变量。 第三次握手：客户机收到确认报文，向服务器发送确认报文为连接分配缓存和变量。 为什么不是两次？ ​ 防止客户端失效的连接请求报文段突然又传到服务器 例如以下情况如果使用两次握手： 如果客户端向服务器发送第一次连接请求在网络节点上滞留了，没有收到服务器的确认，于是又重新发送了一次连接请求 服务器收到客户端的第二次请求发送确认，则连接建立完成 服务器客户端进行数据传输，传输完成断开连接。 此时，在网络上滞留的客户端第一次连接请求到达服务器，服务器发送确认连接但是客户端实际上并没有发送请求，因此不会理睬服务器发送的请求。但是服务器认为连接已完成，并等待客户端进行数据传输。这样会造成资源的浪费 如果采用三次握手的话： 滞留在网络上的客户端第一次请求到达服务器之后，服务器发送确认，但实际上服务器并没有发送请求，因此不会理睬服务器的确认，故不会发送确认，服务器等不到客户端的确认则连接建立失败。这样就防止了客户端失效的连接请求报文段突然又传到服务器 总结这是作者本人的第一次面试，面试的时候很紧张。面试官出了编程题马上就上手去写，没有思考的过程，也没有去问具体的一些要求。导致越写越慌，到最后连斐波那契数列这样的基础题，也没有写出来。基础知识也很不牢靠，一些简单的问题，也没有答上来。 在面试后在网上找了一些《剑指offer》的资料，发现前几章很有帮助，其中比较重要的一点就是，拿到面试题先思考，不理解需求的问，想清楚了之后再具体的写代码。 一些面试题答案的参考文献： https://www.jianshu.com/p/7a9ea6ece2af https://blog.csdn.net/zhaohong_bo/article/details/89552188 https://blog.csdn.net/qq_41727218/article/details/87881235","categories":[{"name":"面经","slug":"面经","permalink":"https://hexuezhi.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"字节跳动","slug":"字节跳动","permalink":"https://hexuezhi.github.io/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"},{"name":"面试","slug":"面试","permalink":"https://hexuezhi.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"python集合的一些基本操作","slug":"python集合的一些基本操作","date":"2020-07-12T13:03:11.494Z","updated":"2020-09-05T12:38:24.191Z","comments":true,"path":"2020/07/12/python集合的一些基本操作/","link":"","permalink":"https://hexuezhi.github.io/2020/07/12/python%E9%9B%86%E5%90%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"刷题过程中有时需要用到集合相关的数据结构，主要是list、set和dict。记录一下如何在刷题过程中应用这些结构。","text":"刷题过程中有时需要用到集合相关的数据结构，主要是list、set和dict。记录一下如何在刷题过程中应用这些结构。 一、list1、列表的创建12345nums = []#快速创建队列并赋值nums = [0 for _ in range(n)]#快速创建二维数组，并赋值nums = [[0 for _ in range(n)] for _ in range(m)] 2、列表的压入12nums.append(x)nums.insert(index,x)#在index插入x 3、列表的删除12x = nums.pop(1)#删除index为1的元素list.remove(2)#删除元素2的第一个匹配项 4、列表排序12nums.sort()nums.sort(key=None,reverse=False) 5、反转列表1nums.reverse() 6、复制列表1nums.copy() 7、列表中某个元素出现的个数1nums.count(x)#x出现的次数 8、某个值的第一个匹配项的index1nums.index(x) 二、set1、集合的创建1nums = &#123;&#125; 2、集合的压入12345nums.add(x)#高级方法nums.update(x)#x可以是列表、元组、字典，且x可以又多个，用逗号隔开nums.update([1,4],[5,6])#&#123;1, 3, 4, 5, 6&#125; 3、集合的删除12nums.remove(x)#如果元素不存在会发生错误nums.discard(x)#如果元素不存在不会发生错误 三、dict1、字典的创建1nums = &#123;&#125; 2、字典的压入1nums[x] = y 3、字典的删除1del nums[x] 4、字典的遍历4.1、遍历键1234for key in nums: print(nums[key])#或者for key in nums.keys(): 4.2、遍历值12for value in nums.values(): print(value) 4.3、遍历键和值1for k,v in nums.items():","categories":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/tags/python/"},{"name":"leetcode","slug":"leetcode","permalink":"https://hexuezhi.github.io/tags/leetcode/"}]},{"title":"python刷题过程中的栈、队列和堆的实现","slug":"python刷题的栈队列和堆的实现","date":"2020-07-12T12:49:55.263Z","updated":"2020-09-05T12:38:38.999Z","comments":true,"path":"2020/07/12/python刷题的栈队列和堆的实现/","link":"","permalink":"https://hexuezhi.github.io/2020/07/12/python%E5%88%B7%E9%A2%98%E7%9A%84%E6%A0%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"刷题过程中有时需要用到栈、队列和堆的数据结构，记录一下如何在刷题过程中快速应用","text":"刷题过程中有时需要用到栈、队列和堆的数据结构，记录一下如何在刷题过程中快速应用 一、栈1、栈的创建1stack = [] 2、栈的压入1stack.append(x) 3、栈的弹出1x = stack.pop() 二、队列1、队列的创建12from collections import dequequeue = deque() 2、队列的压入1queue.append(x) 3、队列的弹出1x = stack.popleft() 三、堆（最小堆）注意：heapq默认是创建的最小堆，如果需要最大堆，就将-x存入堆中。 1、栈的创建12345import heapqheap = []#新建#或者将列表变成小顶堆nums = [......]heapq.heapify(nums) 2、堆的压入1heapq.heappush(heap,x) 3、堆的弹出1heapq.heappop(heaq) 4、寻找序列中最大或最小的N个元素123lista = [64, 92, 93, 83, 85, 50, 10, 49, 28, 60]print(heapq.nlargest(3, lista)) # [93, 92, 85]print(heapq.nsmallest(3, lista)) # [10, 28, 49]","categories":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/tags/python/"},{"name":"leetcode","slug":"leetcode","permalink":"https://hexuezhi.github.io/tags/leetcode/"}]},{"title":"win10下运行hadoop的wordcount程序报错","slug":"WordCount程序报错","date":"2020-06-27T12:15:08.039Z","updated":"2020-09-05T12:38:18.071Z","comments":true,"path":"2020/06/27/WordCount程序报错/","link":"","permalink":"https://hexuezhi.github.io/2020/06/27/WordCount%E7%A8%8B%E5%BA%8F%E6%8A%A5%E9%94%99/","excerpt":"学习hadoop的过程中遇到了一个bug，记录一下过程","text":"学习hadoop的过程中遇到了一个bug，记录一下过程 Exception in thread“main”java.lang.UnsatisfiedLinkError: org.apache.hadoop.io.nativeio.NativeIO$Windows.access0(Ljava/lang/String;I)Z第一步、检查系统环境变量1、检查HADOOP_HOME image-20200627202154495 2、检查PATH image-20200627202320374 第二步、检查hadoop/bin文件夹主要检查是否有winutils.exe和hadoop.dll两个文件。 如果没有的话请从网上下载，要下载对应版本的文件。 第三步、检查C:\\Windows\\System32文件夹检查是否有hadoop.dll文件，如果没有的话，从hadoop/bin文件夹下复制过去。 文章来源：https://sparkbyexamples.com/spark/spark-hadoop-exception-in-thread-main-java-lang-unsatisfiedlinkerror-org-apache-hadoop-io-nativeio-nativeiowindows-access0ljava-lang-stringiz/","categories":[{"name":"hadoop","slug":"hadoop","permalink":"https://hexuezhi.github.io/categories/hadoop/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"https://hexuezhi.github.io/tags/hadoop/"},{"name":"wordcount","slug":"wordcount","permalink":"https://hexuezhi.github.io/tags/wordcount/"}]},{"title":"CentOS7设置防火墙","slug":"CentOS7防火墙设置","date":"2020-06-26T04:22:20.489Z","updated":"2020-11-26T04:08:51.466Z","comments":true,"path":"2020/06/26/CentOS7防火墙设置/","link":"","permalink":"https://hexuezhi.github.io/2020/06/26/CentOS7%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE/","excerpt":"CentOS7设置防火墙，记录一下过程","text":"CentOS7设置防火墙，记录一下过程 1、防火墙设置 启动防火墙：systemctl start firewalld.service 关闭防火墙：systemctl stop firewalld.service 重启防火墙：systemctl restart firewalld.service 显示防火墙状态：systemctl status firewalld.service 开机自动开启防火墙：systemctl enable firewalld.service 开机禁用防火墙：systemctl disable firewalld.service 查看防火墙是否开机启动：systemctl is-enabled firewalld.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled 查看启动失败的服务列表：systemctl --failed 2、防火墙配置 查看版本： firewall-cmd --version 查看帮助： firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口： firewall-cmd --zone=public --list-ports 更新防火墙规则：firewall-cmd --reload 查看区域信息: firewall-cmd --get-active-zones 查看指定接口所属区域：firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态： firewall-cmd --panic-off 查看是否拒绝： firewall-cmd --query-panic 添加开放端口：firewall-cmd --zone=public --add-port=80/tcp --permanent （–permanent永久生效，没有此参数重启后失效） 删除开放端口：firewall-cmd --zone=public --remove-port=80/tcp --permanent 查看开放端口：firewall-cmd --zone=public --query-port=80/tcp","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/categories/CentOS/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/tags/CentOS/"}]},{"title":"scrapy爬虫","slug":"scrapy爬虫","date":"2020-06-15T16:01:06.077Z","updated":"2020-12-05T05:13:51.459Z","comments":true,"path":"2020/06/16/scrapy爬虫/","link":"","permalink":"https://hexuezhi.github.io/2020/06/16/scrapy%E7%88%AC%E8%99%AB/","excerpt":"学习了一下scrapy爬虫，记录一下过程。","text":"学习了一下scrapy爬虫，记录一下过程。 一、新建工程1. 创建项目powershell下： 1scrapy startproject 工程名称 2. 创建爬虫程序12cd 工程名称scrapy genspider 程序名称 爬取的网站地址 注意：==网站地址前面不要有http://之类的== 3. 启动spider1scrapy crawel 程序名称 二、文件说明 scrapy.cfg：项目的配置信息，主要为Scrapy命令行工具提供一个基础的配置信息。（真正爬虫相关的配置信息在settings.py文件中） items.py：设置数据存储模板，用于结构化数据，如：Django的Model pipelines：数据处理行为，如：一般结构化的数据持久化 settings.py：配置文件，如：递归的层数、并发数，延迟下载等 spiders：爬虫目录，如：创建文件，编写爬虫规则 以上命名都是固定的 1. items.py：12345import scrapyclass ThirdItem(scrapy.Item): name = scrapy.Field() age = scrapy.Field() 2. example.pyexample.py是scrapy genspider命令中spider名称 12345678910111213141516171819202122232425262728293031# -*- coding: utf-8 -*-import scrapyfrom urllib import parsefrom scrapy.http import Requestfrom ..items import Item#导入自定义的item结构化数据类class ExampleSpider(scrapy.Spider): name = 'example' allowed_domains = ['example.com'] start_urls = ['http://example.com']#要爬取的网页 def parse(self, response): print(response.body)#打印获取到的网页源码 #获取页面数据的两种方式 #url = response.css(' ').extract() url = response.xpath(' ').extract() for next_url in url: yield Request(url=parse.urljoin(response.url, next_url), callback=self.parse_detail)#parse_detail为自定义函数 def parse_detail(self, response): print(\"================进入parse_detail=================\") print(response.body)#打印url的源码 items = Item() items['name'] = response.xpath(' ').extract_first(\"\") items['name'] = items['name'].replace('\\n', '').replace(' ', '') items['age'] = response.xpath(' ').extract_first(\"\") items['age'] = items['age'].replace('\\n', '').replace(' ', '') yield items 4. main.py在pycharm里，可以将指令写入main.py中，简化操作。 1234from scrapy import cmdline#cmdline.execute(\"scrapy\",\"crawl\",\"example\")cmdline.execute(\"scrapy crawl example\".split()) 如果没有出现运行标志，表示需要配置： 配置 添加新配置 配置信息 ==工作目录需要选择py文件的父文件夹== 三、延迟获取对于浏览器看到的和实际打印的response.body不同的解决方法有两种，两种都可以进行尝试。 1. DOWNLOAD_DELAY在setting.py中找到DOWNLOAD_DELAY取消注释设置值。 1DOWNLOAD_DELAY = 5 #数值越大，延迟越大 2. middleware2.1 安装selenium1pip install selenium 2.2 安装chromedriver注意：==chromedriver的版本一定要与Chrome的版本一致，不然就不起作用。== 查看chrome版本方法：在浏览器地址栏输入chrome://version/ 两个下载地址： http://chromedriver.storage.googleapis.com/index.html https://npm.taobao.org/mirrors/chromedriver/ 解压压缩包，找到chromedriver.exe复制到chrome的安装目录（其实也可以随便放一个文件夹）。复制chromedriver.exe文件的路径并加入到电脑的环境变量中去（不添加也行，得记住路径）。具体的： image-20200407175944138 进入环境变量编辑界面，添加到用户变量即可，双击PATH，将你的文件位置（C:\\Program Files (x86)\\Google\\Chrome\\Application）添加到后面。 image-20200407180622270 打开cmd，输入chromedriver监测是否安装成功。 image-20200407180356103 2.3 配置 将settings.py中的DOWNLOADER_MIDDLEWARES解除注释。 在middlewares.py导入将需要的包并且设置变量。 123456789import timefrom scrapy.http import HtmlResponsefrom selenium import webdriverfrom selenium.common.exceptions import TimeoutExceptionfrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument('--headless')driver = webdriver.Chrome(\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe\",chrome_options=chrome_options) 在middlewares.py找到相应的middleware的类中的process_request函数，函数中添加以下代码，代码块如图。其中起关键作用的是time.sleep(10)，意思是延迟多长时间。延迟后再返回current.url和body。本例中类名为MyCrowlersDownloaderMiddleware，具体类名会根据项目名变化。 1234567try: driver.get(request.url)except TimeoutException: print('超时，丢弃本页', request.url) driver.execute_script('window.stop()')time.sleep(10)return HtmlResponse(url=driver.current_url, body=driver.page_source, encoding=\"utf-8\",request=request) 2.4 滚动加载配置（这部分好像有问题） 在middlewares.py新导入一个包。 1from selenium.common.exceptions import TimeoutException 在process_request函数中添加以下代码，代码块如图。 12345678try: spider.browser.get(request.url) spider.browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')except TimeoutException as e: print('超时') spider.browser.execute_script('window.stop()')time.sleep(2)return HtmlResponse(url=spider.browser.current_url, body=spider.browser.page_source, encoding=\"utf-8\",request=request) 四、保存数据共使用三种保存方法，一种是保存为json文件，一种是直接保存到es中。 1. 保存至json 在piplines.py中添加如下代码 1234567891011121314151617181920212223class ScrapyCodePipeline(object): def process_item(self, item, spider): # print('pipeline got item:',item) return itemfrom scrapy.exporters import JsonItemExporterclass JsonExporterPipleline(object): # 调用scrapy提供的json export导出json文件 def __init__(self): self.file = open('export.json', 'wb') self.exporter = JsonItemExporter(self.file, encoding=\"utf-8\", ensure_ascii=False) self.exporter.start_exporting() def close_spider(self, spider): self.exporter.finish_exporting() self.file.close() def process_item(self, item, spider): self.exporter.export_item(item) return item 在settings.py中找到ITEM_PIPELINES，改成如下。 123456ITEM_PIPELINES = &#123;# item处理方式 # 'scrapy_code.pipelines.ScrapyCodePipeline': 300, 'scrapy_code.pipelines.JsonExporterPipleline': 300, # 'scrapy_code.pipelines.MysqlTwistedPipline': 300, # 'scrapy_code.pipelines.ElasticsearchPipeline': 1&#125; 2. 保存至es中 在piplines.py的同级文件夹下建立Python Package，取名为models，在models下建立es_types.py。目录结构如下： models: _init_.py es_types.py piplines.py 在es_types.py中写入如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# -*- coding: utf-8 -*-# elasticsearch_dsl：https://elasticsearch-dsl.readthedocs.io/en/latest/from elasticsearch_dsl import DocType, Date, Completion, Keyword, Text, Integerfrom elasticsearch_dsl.analysis import CustomAnalyzer#需要在es中安装ik分词器ik_analyzer = CustomAnalyzer(\"ik_max_word\", filter=[\"lowercase\"])from elasticsearch_dsl.connections import connectionses=connections.create_connection(host=\"127.0.0.1\")class jobType(DocType): # 设置index名称和document名称 class Index: name = \"51job\" doc_type = \"_doc\" # settings = &#123; # \"number_of_shards\": 2, # &#125; # TODO:fileds定义 url = Keyword() # 不分词，默认保留256个字符 job_name = Text( analyzer=\"ik_max_word\") # “中华人民共和国国歌”拆分为“中华人民共和国,中华人民,中华,华人,人民共和国,人民,人,民,共和国,共和,和,国国,国歌”，会穷尽各种可能的组合； salary = Text(analyzer=\"ik_smart\") # 将“中华人民共和国国歌”拆分为“中华人民共和国,国歌”将“中华人民共和国国歌”拆分为“中华人民共和国,国歌” company = Text(analyzer=\"ik_max_word\") job_position = Text(analyzer=\"ik_max_word\") experience = Text(analyzer=\"ik_max_word\") education = Text(analyzer=\"ik_max_word\") number_of_people = Integer() published_time = Date() position_detail = Text(analyzer=\"ik_smart\") position_type = Text(analyzer=\"ik_max_word\") location = Text(analyzer=\"ik_max_word\") company_detail = Text(analyzer=\"ik_max_word\") suggest = Completion(analyzer=ik_analyzer) # 搜索建议 def __init__(self,item): super(jobType, self).__init__()#调一下父类的init，避免init重写导致一些init操作没执行 self.assignment(item) # TODO:将item转换为es的数据 def assignment(self, item): # TODO：给没爬到的字段赋默认值：空串 keys = ['url', 'job_name', 'salary', 'company', 'job_position', 'experience', 'education', 'number_of_people', 'published_time', 'position_detail', 'position_type', 'location', 'company_detail'] for key in keys: try: item[key] except: item[key] = '' # TODO：将字段值转换为es的数据 # 虽然只是将原来的item值赋给了成员变量，但这个过程中会执行数据格式转换操作，比如url本来在item是python的字符串类型，转换后变为es的keyword类型 self.url = item['url'] self.job_name = item['job_name'] self.salary = item['salary'] self.company = item['company'] self.job_position = item['job_position'] self.experience = item['experience'] self.education = item['education'] self.number_of_people = item['number_of_people'] self.published_time = item['published_time'] self.position_detail = item['position_detail'] self.position_type = item['position_type'] self.location = item['location'] self.company_detail = item['company_detail'] # # 或者简化代码为 # for key in keys: # vars(self)[key]=item[key] # TODO：生成搜索建议词 self.suggest = self.gen_suggests(((self.job_name, 10), (self.company, 3), (self.position_type, 7))) def gen_suggests(self, info_tuple): # 根据字符串生成搜索建议数组 used_words = set() # set为去重功能 suggests = [] for text, weight in info_tuple: if text: # 字符串不为空时，调用elasticsearch的analyze接口分析字符串（分词、大小写转换） words = es.indices.analyze(body=&#123;'text': text, 'analyzer': \"ik_max_word\"&#125;) # anylyzed_words = set([r[\"token\"] for r in words[\"tokens\"] if len(r[\"token\"]) &gt; 1]) analyzed_words = [] for r in words[\"tokens\"]: if len(r[\"tokens\"]) &gt; 1: analyzed_words.append(r[\"tokens\"]) anylyzed_words = set(analyzed_words) new_words = anylyzed_words - used_words else: new_words = set() if new_words: suggests.append(&#123;'input': list(new_words), 'weight': weight&#125;) return suggests 在piplines.py中添加如下代码 1234567891011121314from .models.es_types import jobTypeclass ElasticsearchPipeline(object): def process_item(self, item, spider): job = jobType(item)# 将item转换为es所需格式 # 将数据传入es # jobType继承自DocType，所以DocType有的函数，它都有。 # save就是DocType定义的将类中的各成员变量打包成数据插入操作，进行数据插入的函数 job.save() #仍返回item，使得运行窗口能看到爬到的数据 return item 在settings.py中找到ITEM_PIPELINES，改成如下。 123456ITEM_PIPELINES = &#123;# item处理方式 # 'scrapy_code.pipelines.ScrapyCodePipeline': 300, # 'scrapy_code.pipelines.JsonExporterPipleline': 300, # 'scrapy_code.pipelines.MysqlTwistedPipline': 300, 'scrapy_code.pipelines.ElasticsearchPipeline': 1&#125;","categories":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/categories/python/"}],"tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://hexuezhi.github.io/tags/scrapy/"}]},{"title":"jar包部署","slug":"jar包部署","date":"2020-06-15T15:56:51.079Z","updated":"2020-10-08T14:59:38.534Z","comments":true,"path":"2020/06/15/jar包部署/","link":"","permalink":"https://hexuezhi.github.io/2020/06/15/jar%E5%8C%85%E9%83%A8%E7%BD%B2/","excerpt":"将项目部署到CentOS上，简单记忆一下部署的方法。","text":"将项目部署到CentOS上，简单记忆一下部署的方法。 前台运行项目（不能关掉shell）1Java -jar xxxxx.jar 后台运行项目（可以关掉shell）1nohup java -jar xxxxx.jar &amp; 后台运行项目不输出.out文件1nohup java -jar xxxxx.jar &gt;/dev/null 2&gt;&amp;1 &amp; 后台运行项目只输出错误信息到文件1nohup java -jar xxxxx.jar &gt;/dev/null 2&gt;error &amp; 停止项目12netstat -anp | grep 8080kill sid xxxx","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/categories/CentOS/"}],"tags":[{"name":"java","slug":"java","permalink":"https://hexuezhi.github.io/tags/java/"}]},{"title":"CentOS7设置网络","slug":"CentOS7设置网络","date":"2020-05-20T12:50:09.968Z","updated":"2020-11-30T14:01:32.398Z","comments":true,"path":"2020/05/20/CentOS7设置网络/","link":"","permalink":"https://hexuezhi.github.io/2020/05/20/CentOS7%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C/","excerpt":"CentOS7设置固定IP，记录一下过程","text":"CentOS7设置固定IP，记录一下过程 本文设置的网络是NAT模式+固定IP。 一、VM设置本文使用的虚拟机时VMware Workstation Pro。 1、设置虚拟机的连接方式选择自己要设置的虚拟机，选择虚拟机(M)-&gt;设置，选择网咯适配器，选择为NAT模式。 image-20200520194124851 2、配置虚拟机的NAT模式具体地址参数选择编辑(E)-&gt;虚拟机网络编辑器，点击更改设置。 image-20200818165231769 选择VMnet8-&gt;取消勾选使用本地DHCP-&gt;设置自己的子网ip（最好设置和自己的主机在同一个域内）-&gt;选择NAT设置。记住NAT设置中的三个地址。 image-20200818174649942 找到计算机控制面板-&gt;网络和Internet-&gt;网络和共享中心-&gt;左侧的更改适配器设置。 先择VMnet8右键属性-&gt;选择IPv4属性-&gt;设置自定ip地址。这里ip地址设置为子网内的ip就可，注意不要和想设置的虚拟机固定IP相同。 image-20200818175557387 二、CentOS7设置本文使用的虚拟机时VMware Workstation Pro。 1、查看网络名和ip首先查看自己需要配置的网络名称和目前的ip地址。 1ip addr {% image https://i.loli.net/2020/06/05/f9mvPKqQbAGILgy.png 'image-20200520202702641' '' %} 2、修改ip地址文件(需要root权限)查看文件夹下文件，找到和自己网络名相同的。 12cd /etc/sysconfig/network-scripts/ls image-20200520203141320 编辑： 1vim ifcfg-ens33 {% image https://i.loli.net/2020/08/18/ZvXwiNpkzrY3lM2.png 'image-20200818180048862' '' %} BOOTPROTO：设置为静态ip ONBOOT：开机启动 DNS1：这里直接设置为114.114.114.114 IPADDR：想设置的虚拟机的固定IP地址 NETMASK：掩码 GATEWAY：网关地址 重启网络服务： 1systemctl restart network.service 验证： 123ip addr#查看自己的ip地址ping 主机地址#windows通过ipconfig获得ping www.baidu.com#查看自己是否能连接到网络 再从主机ping 虚拟机固定ip。 3、添加hosts1vim /etc/hosts 在文件中添加映射即可。例如我是要配置hadoop集群，分别有192.168.2.132、192.168.2.133、192.168.2.134三台机子。可以在hosts中添加如下配置： 123192.168.2.132 hadoop132192.168.2.133 hadoop133192.168.2.134 hadoop134 这时候就可以尝试ping各个主机了： 从本机ping虚拟机：ping 192.168.2.132 从虚拟机ping主机：ping 主机ip 从虚拟机ping虚拟机：ping hadoop133 4、修改hostname1hostnamectl set-hostname xxx 如本机是192.168.40.132，则 1hostnamectl set-hostname hadoop132 然后可以输入如下命令检查hostname： 1hostname","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/categories/CentOS/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/tags/CentOS/"}]},{"title":"CentOS7安装JDK1.8","slug":"CentOS7安装Jdk1.8","date":"2020-05-17T06:31:20.727Z","updated":"2020-10-08T14:48:10.462Z","comments":true,"path":"2020/05/17/CentOS7安装Jdk1.8/","link":"","permalink":"https://hexuezhi.github.io/2020/05/17/CentOS7%E5%AE%89%E8%A3%85Jdk1.8/","excerpt":"为公司服务器安JDK，记录一下过程","text":"为公司服务器安JDK，记录一下过程 第一步、卸载系统自带的OpenJDK及相关的java文件1、查看系统自带OpenJDK版本1java -version 2、查找需要删除的相关文件1rpm -qa | grep java 命令说明： rpm：管理套件 -qa：使用询问模式，查询所有套件 grep：查找文件里符合条件的字符串 java：查找包含java字符串的文件 3、删除文件这里删除带OpenJDK字样的文件即可，例如： 1rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64 命令介绍： rpm：管理套件 -e：删除指定的套件 –nodeps：不验证套件档的相互关联性 4、检查是否删除成功1java -version 出现未找到命令...则表示删除成功。 第二步、下载JDK1.81、下载JDK下载地址：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 这里下载对应的tar.gz文件即可CentOS7对应下载： QQ截图20200517133840 注意：现在下载低于1.8版本的jdk需要登录，从网上找到了一个账号，亲测可用。 账号：2696671285@qq.com 密码：Oracle123 2、上传JDK至服务器注意：如果上一步是直接在CentOS7中下载的这一步可以跳过。笔者是在win10系统中下载的JDK压缩包。 简单说一下，连接你的服务器，通过sftp服务将压缩包上传至服务器。这里好用推荐一个软件：Bitvise SSH Client 登录服务器后，它会自动打开，shell窗口和Sftp窗口。 QQ截图20200517135255 直接上传你的压缩包即可。 第三步、安装JDK1、解压首先需要将压缩包移动到/usr/java文件夹下 1cp jdk-8u251-linux-x64.tar.gz /usr/java 随后到/usr/java下解压 12cd /usr/javatar -zxvf jdk-8u251-linux-x64.tar.gz 2、配置环境变量修改配置文件 1vim /etc/profile 进入文本编辑状态下，光标走到文件最后一行，键盘按下： 1i 进入插入状态： 在文本的最后一行粘贴如下： 注意：JAVA_HOME=/usr/java/jdk1.8.0_251就是你自己的目录 1234\\#java environmentexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_251export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;rt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;dt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;tools.jarexport PATH&#x3D;$PATH:$&#123;JAVA_HOME&#125;&#x2F;bin {% image https://i.loli.net/2020/06/05/1gUVSH2xoQmDleX.png 'image-20200517141720911' '' %} 点击esc进入命令模式，输入：wq!保存修改信息 然后键入以下命令使配置文件生效： 1source /etc/profile 3、检查是否配置成功1java -version image-20200517142140209 至此JDK1.8就安装好了。","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/categories/CentOS/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/tags/CentOS/"},{"name":"JDK","slug":"JDK","permalink":"https://hexuezhi.github.io/tags/JDK/"}]},{"title":"CentOS7安装MySQL5.7","slug":"CentOS7安装MySQL","date":"2020-05-16T12:20:45.876Z","updated":"2020-11-30T14:01:34.501Z","comments":true,"path":"2020/05/16/CentOS7安装MySQL/","link":"","permalink":"https://hexuezhi.github.io/2020/05/16/CentOS7%E5%AE%89%E8%A3%85MySQL/","excerpt":"为公司服务器安装MySQL，记录一下过程","text":"为公司服务器安装MySQL，记录一下过程 注意：在CentOS中默认是装有MariaDB的，但为了需要，还是要在系统中安装MySQL，而且安装完成之后可以直接覆盖掉MariaDB。 第一步： 下载并安装MySQL官方的Yum Repository1、下载安装文件1wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 使用上面的命令就直接下载了安装用的Yum Repository，大概25KB的样子，然后就可以直接yum安装了。 2、执行安装1yum -y install mysql57-community-release-el7-10.noarch.rpm 之后就开始安装MySQL服务器。 1yum -y install mysql-community-server 安装完成，会出现Complete!的提示。 第二步： MySQL数据库设置1、启动MySQL1systemctl start mysqld.service 查看MySQL运行状态，运行状态如图： 1systemctl status mysqld.service 2、查找临时密码通过如下命令可以在日志文件中找出密码： 1grep \"password\" /var/log/mysqld.log 注意：如果这里在日志文件中查找不到密码，很可能是之前安装过MySQL没有卸载干净。 处理方法： 删除原来安装过的mysql残留的数据（这一步非常重要，问题就出在这） 1rm -rf /var/lib/mysql 重启mysqld服务 1systemctl restart mysqld 这时候再去找临时密码就能找到了 1grep 'temporary password' /var/log/mysqld.log 3、进入数据库并修改密码1mysql -uroot -p 输入查找到的临时密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库： 1ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password'; 其中‘new password’替换成你要设置的密码，注意:密码设置必须要大小写字母数字和特殊符号（,/‘;:等）,不然不能配置成功 如果要修改为root这样的弱密码，需要进行以下配置： 查看密码策略 1show variables like '%password%'; 修改密码策略 1vi /etc/my.cnf 在文件中添加一下配置。 选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件 1234#添加validate_password_policy配置validate_password_policy=0#关闭密码策略validate_password = off 重启mysql服务使配置生效 1systemctl restart mysqld 然后就可以修改为弱密码了。 第三步： 开启MySQL远程访问1、开启MySQL的远程访问执行以下命令开启远程访问限制 注意： 1、下面命令开启的可访问数据库的IP： 192.168.0.1，如要开启所有的，用%代替IP 2、需要用自己的密码代替下面的password 1grant all privileges on *.* to 'root'@'192.168.0.1' identified by 'password' with grant option; 然后再输入下面两行命令 12flush privileges; exit; 2、为firewall添加开放端口添加mysql端口3306 1firewall-cmd --zone=public --add-port=3306/tcp --permanent 然后再重新载入 1firewall-cmd --reload","categories":[{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/categories/CentOS/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/tags/CentOS/"},{"name":"MySQL","slug":"MySQL","permalink":"https://hexuezhi.github.io/tags/MySQL/"}]},{"title":"数学公式中的希腊字母读音","slug":"数学公式中的希腊字母读音","date":"2020-05-04T04:02:58.247Z","updated":"2020-09-05T12:39:53.643Z","comments":true,"path":"2020/05/04/数学公式中的希腊字母读音/","link":"","permalink":"https://hexuezhi.github.io/2020/05/04/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%AF%BB%E9%9F%B3/","excerpt":"数学公式中的希腊字母读音。","text":"数学公式中的希腊字母读音。 α：阿尔法 β：背他 γ：伽玛 Δ：德尔塔 ε：艾普西龙 η：依他 θ：西他 λ：拦姆达 μ：缪 ξ：克赛（克西） π：派 ρ：柔 σ：西格玛 φ：fai ω：殴米伽","categories":[{"name":"数学","slug":"数学","permalink":"https://hexuezhi.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"公式","slug":"公式","permalink":"https://hexuezhi.github.io/tags/%E5%85%AC%E5%BC%8F/"}]},{"title":"以太坊搭建私链","slug":"以太坊搭建私链","date":"2020-04-30T04:00:47.472Z","updated":"2020-10-13T05:24:24.859Z","comments":true,"path":"2020/04/30/以太坊搭建私链/","link":"","permalink":"https://hexuezhi.github.io/2020/04/30/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%90%AD%E5%BB%BA%E7%A7%81%E9%93%BE/","excerpt":"创建Dapp的第一步，搭建私链。","text":"创建Dapp的第一步，搭建私链。 一、环境准备go、cmake以及geth资源下载，提取码：qfe2 1.1 安装go 下载源码，上传至opt/module，解压。以下所有的文件解压后的文件夹，全部修改文件夹名为：包名+版本号 1tar -xvf go1.14.6.linux-amd64.tar.gz 设置环境变量，vim /etc/profile。 1234export GOROOT&#x3D;&#x2F;opt&#x2F;module&#x2F;go1.14.6#GOPATH需要自己新建一个文件夹export GOPATH&#x3D;&#x2F;root&#x2F;Code&#x2F;goexport PATH&#x3D;$PATH:&#x2F;opt&#x2F;module&#x2F;go1.14.6&#x2F;bin 执行source /etc/profile更新环境变量配置。 验证安装: 1go version 1.2 安装cmake 下载源码，上传至opt/module，解压 1tar -xvf cmake-3.15.2.tar.gz 设置环境变量，vim /etc/profile。 1export PATH&#x3D;$PATH:&#x2F;opt&#x2F;module&#x2F;cmake3.15.2&#x2F;bin 执行source /etc/profile更新环境变量配置。 安装gcc程序包 1yum install -y gcc gcc-c++ make automake 进入cmke目录执行以下下命令，完成编译。这几步时间有些长，耐心等待。 1234cd cmake3.15.2./bootstrapgmakegmake install 验证安装 1cmake --version 二、安装geth 下载源码，上传至opt/module，解压。 1tar zxvf go-ethereum-1.9.19.tar.gz 设置环境变量，vim /etc/profile。 1export PATH&#x3D;$PATH:&#x2F;opt&#x2F;module&#x2F;go-ethereum1.9.19&#x2F;build&#x2F;bin 执行source /etc/profile更新环境变量配置。 执行以下命令来编译源码 123go env -w GOPROXY=https://goproxy.cncd go-ethereum1.9.19make all 验证安装 1geth version 三、geth操作1、启动节点同步，（搭建私链不需要）1234geth --datadir . --syncmode fast//一快速模式同步区块，只会下载每个区块同和区块体，不会执行验证所有的交易。geth --testnet --datadit . --syncmode fast 2、开发者模式开发者模式：是为方便以太坊开发者在以太坊平台上开发测试所建立的一种模式。开发者模式相比自己搭建私链有很多好处，比如不需要链码，会预留一个拥有巨额ETH的账户，账户之间转账不需要先解锁，采用POA证明方式，自动进行挖矿且有交易才挖矿（不会一直挖矿消耗资源）。总体是类似与ganache的模拟链。 开发者模式的开启方法： 123mkdir devChaincd devChaingeth --datadir . --dev --nodiscover --networkid 1234 --rpc --rpccorsdomain \"*\" --rpcaddr 192.168.2.151 --rpcport 8545 console --allow-insecure-unlock 2&gt;output.log 参数说明： –datadir：以太坊私链的文件目录。 –dev：开启开发者模式。 –nodiscover：不发现同一个networkid其他节点。 –networkid：以太坊的网路id，可以自己任意取值。 –rpc：开启rpc接口，Dapp就是通过rpc方式来与以太坊进行交互。 –rpcaddr：rpc的ip，默认是localhost，这里填写的是CentOS本机的IP。如在本地运行虚拟机，网络IP最好不要用DHCP模式获取，固定IP的设置方法。如是远程服务器，填服务器的ip即可。 –rpcport：rpc端口，需要将防火墙中的8545端口开放，开放方法：防火墙设置 console：开启console，能够和geth交互。 –allow-insecure-unlock：没有这个参数,无法解锁账户。 2&gt;output.log：将输出重定向到文件中。 output.log中会包括私链开启以及挖矿的详细信息，执行以下命令可以查看私链运行状态： 1tail -f output.log 3、搭建私链新建mychain文件夹，创建genesis.json chainId：以太坊的链的id，可以自己随便取值，但是需要注意搭建私链时，这个值不能与以太坊主网或者是测试网的chainId相同。以太坊chainId查询 123456789101112131415161718192021222324252627&#123; \"config\": &#123; \"chainId\": 666, \"homesteadBlock\": 0, \"eip150Block\": 0, \"eip150Hash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"eip155Block\": 0, \"eip158Block\": 0, \"byzantiumBlock\": 0, \"constantinopleBlock\": 0, \"petersburgBlock\": 0, \"istanbulBlock\": 0, \"ethash\": &#123;&#125; &#125;, \"nonce\": \"0x0\", \"timestamp\": \"0x5ddf8f3e\", \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0x47b760\", \"difficulty\": \"0x00002\", \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": &#123; &#125; &#125;, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\"&#125; 在mychain文件夹下，初始化链json 1geth --datadir . init genesis.json 启动私链，networkid和rpcaddr的设置方法同开发者模式。查看输出日志output.log同上。 1geth --datadir . --nodiscover --networkid 1234 --rpc --rpccorsdomain \"*\" --rpcaddr 192.168.2.151 --rpcport 8545 console --allow-insecure-unlock 2&gt;output.log 注意：搭建私链后一定要进行以下测试，看是否能够正常发起交易。 4、私链console验证交易的步骤是： 创建两个账户 执行挖矿 执行转账 查看recipient余额 查看块数量 1eth.blockNumber 创建账户： 1personal.newAccount(\"password\") 执行挖矿：(这一步会生成DAG，花费时间会很长，需要耐心等待到100%) 如果出块速度很慢，可以设置链码的difficulty参数，或者提高虚拟机的内存和核心数量，然后执行miner.start(2)来执行多线程挖矿。 1miner.start(1) 获取账户： 12my=eth.accounts[0]other=eth.accounts[1] 解锁账户（发起交易前需要对sender解锁）： 12personal.unlockAccount(my)//随后输入密码：1234 查看余额： 1eth.getBalance(other) 发起转账： 1eth.sendTransaction(&#123;from:my, to:other, value:10000&#125;) 如果没有挖矿 12txpool.status//查看本地交易池中有没有待确认的交易eth.getBlock(\"pending\",true).transactions//查看当前待确认的交易 查看交易信息： 1eth.getTransaction(\"交易哈希\") 通过区块号查看区块信息： 1eth.getBlock(0)","categories":[{"name":"以太坊","slug":"以太坊","permalink":"https://hexuezhi.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"私链搭建","slug":"私链搭建","permalink":"https://hexuezhi.github.io/tags/%E7%A7%81%E9%93%BE%E6%90%AD%E5%BB%BA/"}]},{"title":"水龙头合约创建发布","slug":"水龙头合约","date":"2020-04-30T03:59:14.175Z","updated":"2020-09-05T12:39:21.505Z","comments":true,"path":"2020/04/30/水龙头合约/","link":"","permalink":"https://hexuezhi.github.io/2020/04/30/%E6%B0%B4%E9%BE%99%E5%A4%B4%E5%90%88%E7%BA%A6/","excerpt":"创建发布水龙头合约。","text":"创建发布水龙头合约。 重要网站： 以太坊链上查询：etherscan.io 以太坊测试链上查询：ropsten.etherscan.io 线上IDE：remix.ethereum.org 合约代码123456789pragma solidity ^0.4.17;contract Faucet&#123; function withdraw(uint amount) public&#123; require (amount &lt;&#x3D; 1000000000000000000); msg.sender.transfer(1000000000000000000); &#125; function() public payable &#123;&#125;&#125; 第一步：编译 QQ截图20200302090418 第二步：部署 QQ截图20200302090449 第三步：查看合约地址，并给地址转账 QQ截图20200302091244 第四步：调用水龙头函数 QQ截图20200302090704 第五步：查看转账 QQ截图20200302090743","categories":[{"name":"以太坊","slug":"以太坊","permalink":"https://hexuezhi.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"水龙头合约","slug":"水龙头合约","permalink":"https://hexuezhi.github.io/tags/%E6%B0%B4%E9%BE%99%E5%A4%B4%E5%90%88%E7%BA%A6/"}]},{"title":"Python MongoDB","slug":"pymongo笔记","date":"2020-04-30T03:48:31.229Z","updated":"2020-09-05T12:38:33.207Z","comments":true,"path":"2020/04/30/pymongo笔记/","link":"","permalink":"https://hexuezhi.github.io/2020/04/30/pymongo%E7%AC%94%E8%AE%B0/","excerpt":"依靠pymongo包来对mongoDB数据库进行操作","text":"依靠pymongo包来对mongoDB数据库进行操作 一、pymongo安装首先通过pip list或者通过import pymongo，查看自己装没装pymongo。 1pip install pymongo 出错提示版本匹配有问题。 通过Anaconda中安装pymongo环境，失败。 重新更新pip版本 1python -m pip install --upgrade pip 更新成功后，再pip install pymongo，成功！！ 二、pymongo基本操作1.创建数据库连接名[&quot;库名&quot;] 1234import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\") #创建名字为runoob的数据库mydb = myclient[\"runoob\"] 2.获取数据库列表连接名.list_database_names() 123456import pymongomyclient = pymongo.MongoClient('mongodb://localhost:27017/')#获取数据库列表dblist = myclient.list_database_names()if \"runoobdb\" in dblist: print(\"数据库已存在！\") 3.创建集合（表）库名[&quot;集合名&quot;] 12345import pymongomyclient = pymongo.MongoClient('mongodb://localhost:27017/')mydb = myclient[\"runoob\"]#创建名字为sites的集合mycol = mydb[\"sites\"] 4.获取集合列表库名.list_collection_names() 1234567import pymongomyclient = pymongo.MongoClient('mongodb://localhost:27017/')mydb = myclient['runoobdb']#获取集合列表collist = mydb.list_collection_names()if \"sites\" in collist: # 判断 sites 集合是否存在 print(\"集合已存在！\") 5.插入文档5.1 插入单个文档集合名.inset_one() 该方法返回 InsertOneResult 对象，该对象包含 inserted_id 属性，它是插入文档的 id 值。 123456789import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]mydict = &#123;\"name\":\"RUNOOB\",\"alexa\":\"10000\",\"url\":\"https://www.runoob.com\"&#125;x = mycol.insert_one(mydict) print(x)print(x.inserted_id) 5.2 插入多个文档集合名.inset_many() 1234567891011121314151617import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]mylist = [ &#123; \"name\": \"Taobao\", \"alexa\": \"100\", \"url\": \"https://www.taobao.com\" &#125;, &#123; \"name\": \"QQ\", \"alexa\": \"101\", \"url\": \"https://www.qq.com\" &#125;, &#123; \"name\": \"Facebook\", \"alexa\": \"10\", \"url\": \"https://www.facebook.com\" &#125;, &#123; \"name\": \"知乎\", \"alexa\": \"103\", \"url\": \"https://www.zhihu.com\" &#125;, &#123; \"name\": \"Github\", \"alexa\": \"109\", \"url\": \"https://www.github.com\" &#125;]x = mycol.insert_many(mylist)# 输出插入的所有文档对应的 _id 值print(x.inserted_ids) 5.2 插入多个文档（指定_id）1234567891011121314151617import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"site2\"]mylist = [ &#123; \"_id\": 1, \"name\": \"RUNOOB\", \"cn_name\": \"菜鸟教程\"&#125;, &#123; \"_id\": 2, \"name\": \"Google\", \"address\": \"Google 搜索\"&#125;, &#123; \"_id\": 3, \"name\": \"Facebook\", \"address\": \"脸书\"&#125;, &#123; \"_id\": 4, \"name\": \"Taobao\", \"address\": \"淘宝\"&#125;, &#123; \"_id\": 5, \"name\": \"Zhihu\", \"address\": \"知乎\"&#125;]x = mycol.insert_many(mylist)# 输出插入的所有文档对应的 _id 值print(x.inserted_ids) 6.查询文档6.1 查询单个文档集合名.find_one() 123456789import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]x = mycol.find_one()#无条件，即为第一条数据print(x) 6.2 查询所有文档集合名.find() 12345678910import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017\")mydb = myclient[\"runoob\"]mycol = mydb[\"sites\"]for x in mycol.find() print(x) for y in mycol.find(&#123;&#125;,&#123;\"_id\":0,\"title\":1&#125;) print(y) ==除了 _id ，你不能在一个对象中同时指定 0 和 1（如{ “name”: 1, “alexa”: 0 }），如果你设置了一个字段为 0，则其他都为 1，反之亦然。== 6.3 查询指定条件文档1234567891011import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]#查询名字为RUNOOB的文档myquery = &#123; \"name\": \"RUNOOB\" &#125; mydoc = mycol.find(myquery)for x in mydoc: print(x) 6.4 高级查询基本和mongoDB中写法相同。 123456789101112import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]myquery = &#123; \"name\": &#123; \"$gt\": \"H\" &#125; &#125; mydoc = mycol.find(myquery) for x in mydoc: print(x) 6.5 使用正则表达式匹配字符串123456789101112import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]#\"$regex\"表示使用正则表达式，\"^R\"表示首字母为Rmyquery = &#123; \"name\": &#123; \"$regex\": \"^R\" &#125; &#125;mydoc = mycol.find(myquery)for x in mydoc: print(x) 6.6 返回指定记录数集合名.find().limit(num) 1234567891011import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]myresult = mycol.find().limit(3)# 输出结果for x in myresult: print(x) 7.修改文档7.1 修改单个文档集合名.update_one() 12345678910111213import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]myquery = &#123; \"alexa\": \"10000\" &#125;newvalues = &#123; \"$set\": &#123; \"alexa\": \"12345\" &#125; &#125;mycol.update_one(myquery, newvalues)# 输出修改后的 \"sites\" 集合for x in mycol.find(): print(x) 7.1 修改多个文档集合名.update_many() 123456789101112import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]myquery = &#123; \"alexa\": &#123; \"$reget\":\"^F\"&#125; &#125;newvalues = &#123; \"$set\": &#123; \"alexa\": \"123\" &#125; &#125;x = mycol.update_many(myquery, newvalues)# 输出修改匹配的数量print(x.modified_count, \"文档已修改\") 8.排序文档集合名.find().sort() 12345678import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]#\"-1\"为降序排列mydoc = mycol.find().sort(\"alexa\",-1)for x in mydoc: print(x) 9.删除数据9.1 删除单个文档集合名.delete_one() 1234567891011import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] myquery = &#123; \"name\": \"Taobao\" &#125;mycol.delete_one(myquery)# 删除后输出for x in mycol.find(): print(x) 9.2 删除多个文档集合名.delete_many() 12345678910import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] myquery = &#123; \"name\": &#123;\"$reget\":\"^F\"&#125; &#125;x = mycol.delete_many(myquery)# 删除后输出print(x.deleted_count, \"个文档已删除\") 9.3 删除所有文档集合名.delete_many() 123456789import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] #传入空的查询对象x = mycol.delete_many(&#123;&#125;)# 删除后输出print(x.deleted_count, \"个文档已删除\") 9.4 删除集合集合名.drop() 123456import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] mycol.drop()","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://hexuezhi.github.io/categories/MongoDB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/tags/python/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://hexuezhi.github.io/tags/MongoDB/"}]},{"title":"MongoDB学习笔记","slug":"mongdb","date":"2020-04-30T03:48:16.857Z","updated":"2020-11-27T10:52:39.426Z","comments":true,"path":"2020/04/30/mongdb/","link":"","permalink":"https://hexuezhi.github.io/2020/04/30/mongdb/","excerpt":"在菜鸟教程中学了MongoDB，做此笔记以记录。","text":"在菜鸟教程中学了MongoDB，做此笔记以记录。 一、MongoDB安装1.下载官方下载地址：https://www.mongodb.com/download-center/community 快速下载地址：http://dl.mongodb.org/dl/win32/x86_64 2.安装点击custom可以修改安装目录，另外取消勾选Install MongoDB Compass选项。此为图形界面管理工具。 3.配置 将bin文件夹配置到PATH的环境变量中。 在data文件夹下手动创建db和log 在log文件夹下创建mongodb.log 在安装文件夹下新建mongo.config 文件中写入 12345678910111213141516171819#数据文件，路径必须是你自己的电脑的对应路径dbpath&#x3D;D:\\Program Files\\MongoDB\\Server\\4.2\\data\\db#日志文件 logpath&#x3D;D:\\Program Files\\MongoDB\\Server\\4.2\\data\\log\\mongodb.log#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件logappend&#x3D;true #启用日志文件，默认启用journal&#x3D;true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet&#x3D;true #端口号 默认为27017port&#x3D;27017 点击mongod.exe，如果闪一下退出，说明安装正常。进入测试地址localhost:27017。 进入bin文件夹，使用如下命令： 1mongod --config D:\\Program Files\\MongoDB\\Server\\4.2\\mongo.config --install --serviceName &quot;MongoDB&quot; 右键我的电脑，管理查看mongoDB服务是否自动开启。 Warning: 原因：新版本的MongDB增加了安全性设计，推荐用户创建使用数据库时进行验证。如果用户想建立简单连接，则会提示警示信息。 解决方案：创建管理员并设置密码 12345678&gt;use admin&gt;db.createUser( &#123; user: &quot;admin&quot;, &#x2F;&#x2F;用户名 pwd: &quot;passwd&quot;, &#x2F;&#x2F;密码 roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ] &#x2F;&#x2F;设置权限 &#125;) 二、Robo 3T安装1.下载官方下载地址：https://robomongo.org/download 2.建立连接点击Create， {% image https://i.loli.net/2020/06/05/MvmSsP2EQZG3huK.png 'QQ截图20200224202820' '' %} 修改连接名，save {% image https://i.loli.net/2020/06/05/j5spKWLImNF6ic9.png 'QQ截图20200224202902' '' %} 三、基本概念1.概念 MongoDB有着与您熟知的‘数据库’（database，对于Oracle就是‘schema’）一样的概念。在一个MongoDB的实例中您有若干个数据库或者一个也没有，不过这里的每一个数据库都是高层次的容器，用来储存其他的所有数据。 一个数据库可以有若干‘集合’（collection），或者一个也没有。集合和传统概念中的‘表’有着足够多的共同点，所以您大可认为这两者是一样的东西。 集合由若干‘文档’（document）组成，也可以为空。类似的，可以认为这里的文档就是‘行’。 文档又由一个或者更多个‘域’（field）组成，您猜的没错，域就像是‘列’。 ‘索引’（index）在MongoDB中的意义就如同索引在RDBMS中一样。 ‘游标’（cursor）和以上5个概念不同，它很重要但是却常常被忽略，有鉴于此我认为应该进行专门讨论。关于游标有一点很重要，就是每当向MongoDB索要数据时，它总是返回一个游标。基于游标我们可以作诸如计数或是直接跳过之类的操作，而不需要真正去读数据。 小结一下，MongoDB由‘数据库’组成，数据库由‘集合’组成，集合由‘文档’组成。‘域’组成了文档，集合可以被‘索引’，从而提高了查找和排序的性能。最后，我们从MongoDB读取数据的时候是通过‘游标’进行的，除非需要，游标不会真正去作读的操作。 2._id生成规则MongoDB的文档必须有一个_id键。 目的是为了确认在集合里的每个文档都能被唯一标识。 ObjectId 是 _id 的默认类型。 ObjectId 采用12字节的存储空间，每个字节两位16进制数字，是一个24位的字符串。 12位生成规则： [0,1,2,3] [4,5,6] [7,8] [9,10,11] 时间戳 |机器码 |PID |计数器 前四字节是时间戳，可以提供秒级别的唯一性。 接下来三字节是所在主机的唯一标识符，通常是机器主机名的散列值。 接下来两字节是产生ObjectId的PID，确保同一台机器上并发产生的ObjectId是唯一的。 前九字节保证了同一秒钟不同机器的不同进程产生的ObjectId时唯一的。 最后三字节是自增计数器，确保相同进程同一秒钟产生的ObjectId是唯一的。 四、语法格式1.创建数据库1use DATABASE_NAME 如果数据库不存在，则创建。否则切换到指定数据库 2.查看所有数据库（无数据则不显示）1show dbs 3.删库（先use，再drop）12use runoobdb.dropDatabase() 4.创建集合（表）12db.createCollection(name, options)&#x2F;&#x2F;注意Colle“C”大写db.createCollection(&quot;mycol&quot;,&#123;capped:true,autoIndexId:true,size:6142800,max:10000&#125;) name：要创建的集合名字 options：可选参数 字段 类型 描述 capped 布尔 （可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。 当该值为 true 时，必须指定 size 参数。 autoIndexId 布尔 （可选）如为 true，自动在 _id 字段创建索引。默认为 false。 size 数值 （可选）为固定集合指定一个最大值，以千字节计（KB）。 如果 capped 为 true，也需要指定该字段。 max 数值 （可选）指定固定集合中包含文档的最大数量。 在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。 12 5.查看集合1show collections 6.删除集合1db.COLLECTION_NAME.drop() 7.插入文档（一条记录）1234567891011db.COLLECTION_NAME.insert(document)db.collection.insertOne(&#123;&quot;a&quot;: 3&#125;)db.collection.insertMany([&#123;&quot;b&quot;: 3&#125;, &#123;&#39;c&#39;: 4&#125;])&#x2F;&#x2F;例子，该集合不在该数据库中，MongoDB会自动创建该集合并插入文档。db.col.insert(&#123;title: &#39;MongoDB 教程&#39;, description: &#39;MongoDB 是一个 Nosql 数据库&#39;, by: &#39;菜鸟教程&#39;, url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;, tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;], likes: 100&#125;) 也可以将数据定义为一个变量,然后插入： 12345678document&#x3D;(&#123;title: &#39;MongoDB 教程&#39;, description: &#39;MongoDB 是一个 Nosql 数据库&#39;, by: &#39;菜鸟教程&#39;, url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;, tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;], likes: 100&#125;);db.col.insert(document) 8.查看已插入文档12db.COLLECTION_NAME.find()db.COLLECTION_NAME.find().pretty()&#x2F;&#x2F;格式优化 9.更新文档12345678910db.collection.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;)db.col.update(&#123;&#39;title&#39;:&#39;MongoDB 教程&#39;&#125;,&#123;$set:&#123;&#39;title&#39;:&#39;MongoDB&#39;&#125;&#125;,&#123;multi:true&#125;) query : update的查询条件，类似sql update查询内where后面的。 update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。 save() 方法通过传入的文档来替换已有文档。语法格式如下： 123456db.collection.save( &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125;) document : 文档数据。 writeConcern :可选，抛出异常的级别。 123456789101112db.col.save(&#123; &quot;_id&quot; : ObjectId(&quot;56064f89ade2f21f36b03136&quot;), &quot;title&quot; : &quot;MongoDB&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;, &quot;by&quot; : &quot;Runoob&quot;, &quot;url&quot; : &quot;http:&#x2F;&#x2F;www.runoob.com&quot;, &quot;tags&quot; : [ &quot;mongodb&quot;, &quot;NoSQL&quot; ], &quot;likes&quot; : 110&#125;) 10.删除文档12345678db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;)db.col.remove(&#123;&#39;title&#39;:&#39;MongoDB 教程&#39;&#125;) query :（可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。 writeConcern :（可选）抛出异常的级别。 11.查询文档1db.collection.find(query, projection) query ：可选，使用查询操作符指定查询条件 projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略） 如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下： 1db.col.find().pretty() 11.1 ==比较操作符== 操作 格式 范例 RDBMS中的类似语句 等于 {:} db.col.find({&quot;by&quot;:&quot;菜鸟教程&quot;}).pretty() where by = &#39;菜鸟教程&#39; 小于 {:{$lt:}} db.col.find({&quot;likes&quot;:{$lt:50}}).pretty() where likes &lt; 50 小于等于 {:{$lte:}} db.col.find({&quot;likes&quot;:{$lte:50}}).pretty() where likes &lt;= 50 大于 {:{$gt:}} db.col.find({&quot;likes&quot;:{$gt:50}}).pretty() where likes &gt; 50 大于等于 {:{$gte:}} db.col.find({&quot;likes&quot;:{$gte:50}}).pretty() where likes &gt;= 50 不等于 {:{$ne:}} db.col.find({&quot;likes&quot;:{$ne:50}}).pretty() where likes != 50 11.2 AND比较条件多条件间以逗号隔开 1db.col.find(&#123;key1:value1, key2:value2&#125;).pretty() 11.3 OR比较条件123456789db.col.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty()&#x2F;&#x2F;举例子db.col.find(&#123;$or:[&#123;&quot;by&quot;:&quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty() 11.4 AND 和 OR 联合使用1db.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty() 11.5 使用 (&lt;) 和 (&gt;) 查询1db.col.find(&#123;likes : &#123;$lt :200, $gt : 100&#125;&#125;) 11.6 $type操作符1db.col.find(&#123;&quot;title&quot; : &#123;$type : &#39;string&#39;&#125;&#125;) 12.Limit与Skip方法1db.COLLECTION_NAME.find().limit(NUMBER) ==db.col.find({},{“title”:1,_id:0}).limit(2)== 1db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) 13.排序sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。 1db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;) 14.创建索引12db.collection.createIndex(keys, options)db.values.createIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;) Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。 createIndex() 接收可选参数，可选参数列表如下： Parameter Type Description background Boolean 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。 unique Boolean 建立的索引是否唯一。指定为true创建唯一索引。默认值为false. name string 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。 dropDups Boolean 3.0+版本已废弃。在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false. sparse Boolean 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false. expireAfterSeconds integer 指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。 v index version 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。 weights document 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。 default_language string 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语 language_override string 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language. 15.聚合1db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION) 表达式 描述 实例 $sum 计算总和。 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}]) $avg 计算平均值 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}]) $min 获取集合中所有文档对应值得最小值。 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}]) $max 获取集合中所有文档对应值得最大值。 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}]) $push 在结果文档中插入值到一个数组中。 db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}]) $addToSet 在结果文档中插入值到一个数组中，但不创建副本。 db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}]) $first 根据资源文档的排序获取第一个文档数据。 db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}]) $last 根据资源文档的排序获取最后一个文档数据 db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}]) 16.管道管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。 MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。 表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。 这里我们介绍一下聚合框架中常用的几个操作： $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 123456db.article.aggregate( &#123; $project : &#123; title : 1 , author : 1 , &#125;&#125; ); 这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，如果要想不包含_id话可以这样: 123456db.article.aggregate( &#123; $project : &#123; _id : 0 , title : 1 , author : 1 &#125;&#125;); 五、维护1.副本集？2.分片集？3.备份(mongodump)与恢复(mongorestore)备份mongodump 12mongodump -h dbhost -d dbname -o dbdirectorymongodump -h 127.0.0.1:27017 -d TestBase -o D:\\data\\home\\momgodump -h： MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d： 需要备份的数据库实例，例如：test -o： 备份的数据存放位置，例如：c:\\data\\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 恢复mongorestore 12mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;mongorestore -h 127.0.0.1:27017 -d TestBase --dir D:\\data\\home\\momgodump\\TestBase –host &lt;:port&gt;, -h &lt;:port&gt;： MongoDB所在服务器地址，默认为： localhost:27017 –db , -d ： 需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2 –drop： 恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！ ： mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\\data\\dump\\test。 你不能同时指定 和 –dir 选项，–dir也可以设置备份目录。 –dir： 指定备份的目录 你不能同时指定 和 –dir 选项。 4.监控mongostat会间隔固定时间获取mongodb的当前运行状态，并输出。 1mongostat mongotop提供了一个方法，用来跟踪一个MongoDB的实例，查看哪些大量的时间花费在读取和写入数据。 mongotop提供每个集合的水平的统计数据。默认情况下，mongotop返回值的每一秒。 1mongotop 5.Mongodb to Json1mongoexport -h 连接地址 --port 端口 --authenticationDatabase admin -u 用户名 -p 密码 -d 数据库名字 -c 集合名 -o D:\\tx.json --authenticationDatabase admin不加这个参数会出现错误。","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://hexuezhi.github.io/categories/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://hexuezhi.github.io/tags/MongoDB/"}]},{"title":"Typora+PicGo+七牛云 个人博客方案","slug":"Typora+PicGo+七牛云 个人博客方案","date":"2020-04-30T03:23:35.425Z","updated":"2020-09-05T12:38:29.336Z","comments":true,"path":"2020/04/30/Typora+PicGo+七牛云 个人博客方案/","link":"","permalink":"https://hexuezhi.github.io/2020/04/30/Typora+PicGo+%E4%B8%83%E7%89%9B%E4%BA%91%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%96%B9%E6%A1%88/","excerpt":"选择Typora+PicGo+七牛云这一套个人博客方案，简化自己创建博客过程。","text":"选择Typora+PicGo+七牛云这一套个人博客方案，简化自己创建博客过程。 注意：七牛云的域名只能用一个月，所以最好拥有一个备案的域名。不然一个月后的图床域名会被回收，之前上传的图片无法下载，只能通过官方工具来下载。至于如何通过官方工具来下载图片，后期再更新吧。总之，这是个悲伤的故事。 1. PicGo的下载安装下载地址：https://molunerfinn.com/PicGo/ 找到图床设置，七牛图床。 QQ截图20200430105256 查看自己需要的配置项。 QQ截图20200430105451 需要填写的配置项： AccessKey：接入公钥。 SecretKey：自己的私钥。 存储空间名：七牛云上设置的存储空间名。 访问地址：七牛云上空间的外链访问地址。 存储区域：创建空间时，选择的存储区域，从z0到z1，依次对应：华东、华北、华南、北美、东南亚。 2. 七牛云图床创建七牛云官网：https://www.qiniu.com/ 注册选择个人用户，登录并个人身份认证。 点击自己的头像，选择秘钥管理。 QQ截图20200430110237 这样就可以看到自己的AccessKey和SercetKey了。复制粘贴到PicGo的配置中。 在左边侧边栏中找到对象存储。 QQ截图20200430110522 找到空间管理，选择新建空间。 QQ截图20200430110657 在新建空间时可以设置响应的空间名，存储区域。 存储区域选择一个举例自己位置近的即可。注意：填在PicGo的存储区域，是相应的区域代码：z0-z4 访问控制选择公开。 这样就可以在PicGo中填入，空间名和存储区域。 QQ截图20200430110926 现在就差一个访问地址没有填了。 这个可以在空间管理，找到自己刚创建的空间，选择后面的概览，进入概览后选择文件管理，这样就看到自己的外链域名了。（注意：这个地址不可复制） QQ截图20200430111715 将地址输入PicGo的配置中，在指定存储路径中添加img/。 这样PicGo就配置好了。 3. Typora配置选择文件-&gt;偏好设置-&gt;图像。按照图中配置，配置完验证图片上传选项即可。 QQ截图20200430112103","categories":[{"name":"个人博客","slug":"个人博客","permalink":"https://hexuezhi.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"图床应用","slug":"图床应用","permalink":"https://hexuezhi.github.io/tags/%E5%9B%BE%E5%BA%8A%E5%BA%94%E7%94%A8/"}]},{"title":"功能测试","slug":"test","date":"2020-01-03T03:41:23.267Z","updated":"2020-12-03T12:41:03.769Z","comments":true,"path":"2020/01/03/test/","link":"","permalink":"https://hexuezhi.github.io/2020/01/03/test/","excerpt":"测试一些博客的功能","text":"测试一些博客的功能","categories":[{"name":"测试","slug":"测试","permalink":"https://hexuezhi.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://hexuezhi.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"Numpy学习笔记","slug":"Numpy","date":"2020-01-01T07:49:09.931Z","updated":"2020-11-25T16:13:25.514Z","comments":true,"path":"2020/01/01/Numpy/","link":"","permalink":"https://hexuezhi.github.io/2020/01/01/Numpy/","excerpt":"学习Numpy的基本应用","text":"学习Numpy的基本应用 首先需要导入Numpy包 1from numpy import * 一、ndarray数组1、数组的生成1&gt;&gt;&gt;a = array([0,1,2,3]) 可以与C语言一样用索引来定位数组元素，如： 1&gt;&gt;&gt;a[0] = 5 也可以将数组改为二维数组 1234&gt;&gt;&gt;a.shape = 2,2&gt;&gt;&gt;print(a) [[5 1] [2 3]] 特例： 12345678910111213141516&gt;&gt;&gt;b = zeros((2,3),dtype=int)#生成2行3列的0填充数组 [[0 0 0] [0 0 0]]&gt;&gt;&gt;a = ones((3,2),dtype=int) * 5 [[5 5] [5 5] [5 5]]&gt;&gt;&gt;b.fill(-4.8)#向数组中填充元素，填充元素会转化为数组原数据类型 [[-4 -4 -4] [-4 -4 -4]]&gt;&gt;&gt;a = arange(0,80,10)#start到end间隔是10左闭右开 array([ 0, 10, 20, 30, 40, 50, 60, 70])&gt;&gt;&gt;a = identity(3,dtype=int)#生成单位矩阵 array([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]]) 2、数组的类型 复数数组 1234&gt;&gt;&gt;a = array([1 + 1j, 2, 3, 4])&gt;&gt;&gt;a.real#实部&gt;&gt;&gt;a.imag#虚部&gt;&gt;&gt;a.conj()#查看共轭 类型转换： 12&gt;&gt;&gt;asarray(a, dtype=float64)#不会修改原数组的值,但转换与原数组类型相同时返回引用&gt;&gt;&gt;a.astype(float64)#无论何时返回复制 3、数组的属性1234&gt;&gt;&gt;a.size#数组的大小&gt;&gt;&gt;a.shape#数组的形状&gt;&gt;&gt;a.nbytes#数组元素所占空间&gt;&gt;&gt;a.ndim#数组维数 4、数组索引切片 花式索引：与切片不同花式索引返回的是对象的一个复制不是引用。 12&gt;&gt;&gt;indices = [1, 2, -3]&gt;&gt;&gt;y = a[indices] 还可以用bool值 12&gt;&gt;&gt;mask = array([0,1,1,0,0,1,0,0],dtype=bool)&gt;&gt;&gt;a[mask] mask数组可以用布尔表达式生成 1234&gt;&gt;&gt;from numpy.random import rand&gt;&gt;&gt;a = rand(10)#生成[0,1)之间的10个随机数&gt;&gt;&gt;mask = a &gt; 0.5&gt;&gt;&gt;a[mask] 二维花式索引： 123456&gt;&gt;&gt;a[(0,1,2,3,4), (1,2,3,4,5)]#行标列标一一对应，a[0,1],a[1,2]...5个数&gt;&gt;&gt;a[3:, [0,2,5]]#第四行后，1,3,6列&gt;&gt;&gt;mask = array([1,0,1,0,0,1],dtype=bool)&gt;&gt;&gt;a[mask, 2]#依然可以用mask索引&gt;&gt;&gt;y = a[:3]#返回前3行 where语句： 12345&gt;&gt;&gt;loc = where(a &gt; 10)&gt;&gt;&gt;a[loc] (array([0, 0, 1, 1], dtype=int64), array([1, 3, 2, 3], dtype=int64)) #如同二维花式索引，行列坐标一一对应&gt;&gt;&gt;rows, cols = where(a&gt;10) 5、数组的方法求和： 123456&gt;&gt;&gt;a = array([[1,2,3],[4,5,6]])a.sum(axis=1)&gt;&gt;&gt;sum(a)&gt;&gt;&gt;sum(a,axis=0)#或者a.sum(axis=0)沿着第一维度增方向求和，得到行向量 array([5, 7, 9])&gt;&gt;&gt;sum(a,axis=1)#或者a.sum(axis=1)沿着第而维度增方向求和，得到类向量 array([ 6, 15]) 求积： 12&gt;&gt;&gt;a.prod()&gt;&gt;&gt;prod(a, axis=0) 最大值最小值： 1234&gt;&gt;&gt;a.max()#全局最大&gt;&gt;&gt;a.max(axis=-1)&gt;&gt;&gt;a.min()#全局最小&gt;&gt;&gt;a.min(axis=0)#沿着第一维度最小，得到行向量 最大值最小值位置： 12&gt;&gt;&gt;a.argmin()&gt;&gt;&gt;a.argmax(axis=0) 均值： 123&gt;&gt;&gt;a.mean()&gt;&gt;&gt;a.mean(axis=-1)&gt;&gt;&gt;average(a, axis = 0, weights=[1,2])#可以算加权平均 标准差： 1&gt;&gt;&gt;a.std(axis=1) 方差： 1&gt;&gt;&gt;a.var(axis=1) 将数值限制在某个范围内： 1234&gt;&gt;&gt;a = array([[1, 2, 3],[4, 5, 6]])&gt;&gt;&gt;a.clip(3,5) array([[3, 3, 3], [4, 5, 5]]) 计算最大值与最小值之差： 1&gt;&gt;&gt;a.ptp(axis=1) 近似方法： 1&gt;&gt;&gt;a.round(decimals=1)#近似到以为小数 6、数组排序分为函数和方法注意：其他三种不改变原数组，只有data.sort()方法会改变 1234&gt;&gt;&gt;sort(weights)#函数&gt;&gt;&gt;data.sort()#方法 注意注意&gt;&gt;&gt;argsort(weights)#函数&gt;&gt;&gt;data.argsort()#方法 对二维数组默认相当于对每一行的元素进行排序 12345678910111213&gt;&gt;&gt;a = array([ [.2, .1, .5], [.4, .8, .3], [.9, .6, .7] ])&gt;&gt;&gt;sort(a) array([[ 0.1, 0.2, 0.5], [ 0.3, 0.4, 0.8], [ 0.6, 0.7, 0.9]])&gt;&gt;&gt;sort(a, axis = 0) array([[ 0.2, 0.1, 0.3], [ 0.4, 0.6, 0.5], [ 0.9, 0.8, 0.7]]) 7、数组形状修改形状 123&gt;&gt;&gt;a = arange(6)&gt;&gt;&gt;a.shape = 2,3&gt;&gt;&gt;b = a.reshape(3,2)#返回一个新数组 数组连接 12345678910x = array([ [0,1,2], [10,11,12] ])y = array([ [50,51,52], [60,61,62] ])z = concatenate((x,y))#第一维度连接z = concatenate((x,y), axis=1)#第二维度连接 降维 123a = array([[0,1], [2,3]])b = a.flatten()#降为1维数组 8、数组对角线123&gt;&gt;&gt;a.diagonal()&gt;&gt;&gt;a.diagonal(offset=1)#对角线右移&gt;&gt;&gt;a.diagonal(offset=-1)#对角线左移","categories":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/tags/python/"},{"name":"Nunpy","slug":"Nunpy","permalink":"https://hexuezhi.github.io/tags/Nunpy/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/categories/python/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://hexuezhi.github.io/categories/Tomcat/"},{"name":"Go","slug":"Go","permalink":"https://hexuezhi.github.io/categories/Go/"},{"name":"分类","slug":"分类","permalink":"https://hexuezhi.github.io/categories/%E5%88%86%E7%B1%BB/"},{"name":"typora","slug":"typora","permalink":"https://hexuezhi.github.io/categories/typora/"},{"name":"算法","slug":"算法","permalink":"https://hexuezhi.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://hexuezhi.github.io/categories/leetcode/"},{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/categories/CentOS/"},{"name":"bug","slug":"bug","permalink":"https://hexuezhi.github.io/categories/bug/"},{"name":"以太坊","slug":"以太坊","permalink":"https://hexuezhi.github.io/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"面经","slug":"面经","permalink":"https://hexuezhi.github.io/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"hadoop","slug":"hadoop","permalink":"https://hexuezhi.github.io/categories/hadoop/"},{"name":"数学","slug":"数学","permalink":"https://hexuezhi.github.io/categories/%E6%95%B0%E5%AD%A6/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://hexuezhi.github.io/categories/MongoDB/"},{"name":"个人博客","slug":"个人博客","permalink":"https://hexuezhi.github.io/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"测试","slug":"测试","permalink":"https://hexuezhi.github.io/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"pip","slug":"pip","permalink":"https://hexuezhi.github.io/tags/pip/"},{"name":"乱码","slug":"乱码","permalink":"https://hexuezhi.github.io/tags/%E4%B9%B1%E7%A0%81/"},{"name":"环境变量","slug":"环境变量","permalink":"https://hexuezhi.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"文件","slug":"文件","permalink":"https://hexuezhi.github.io/tags/%E6%96%87%E4%BB%B6/"},{"name":"标签","slug":"标签","permalink":"https://hexuezhi.github.io/tags/%E6%A0%87%E7%AD%BE/"},{"name":"scrapy","slug":"scrapy","permalink":"https://hexuezhi.github.io/tags/scrapy/"},{"name":"01背包问题","slug":"01背包问题","permalink":"https://hexuezhi.github.io/tags/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"java","slug":"java","permalink":"https://hexuezhi.github.io/tags/java/"},{"name":"oh-my-zsh","slug":"oh-my-zsh","permalink":"https://hexuezhi.github.io/tags/oh-my-zsh/"},{"name":"bug","slug":"bug","permalink":"https://hexuezhi.github.io/tags/bug/"},{"name":"docker","slug":"docker","permalink":"https://hexuezhi.github.io/tags/docker/"},{"name":"tomcat","slug":"tomcat","permalink":"https://hexuezhi.github.io/tags/tomcat/"},{"name":"nginx","slug":"nginx","permalink":"https://hexuezhi.github.io/tags/nginx/"},{"name":"以太坊","slug":"以太坊","permalink":"https://hexuezhi.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"inputData","slug":"inputData","permalink":"https://hexuezhi.github.io/tags/inputData/"},{"name":"Dapp","slug":"Dapp","permalink":"https://hexuezhi.github.io/tags/Dapp/"},{"name":"truffle","slug":"truffle","permalink":"https://hexuezhi.github.io/tags/truffle/"},{"name":"面试","slug":"面试","permalink":"https://hexuezhi.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"字节跳动","slug":"字节跳动","permalink":"https://hexuezhi.github.io/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"},{"name":"python","slug":"python","permalink":"https://hexuezhi.github.io/tags/python/"},{"name":"leetcode","slug":"leetcode","permalink":"https://hexuezhi.github.io/tags/leetcode/"},{"name":"hadoop","slug":"hadoop","permalink":"https://hexuezhi.github.io/tags/hadoop/"},{"name":"wordcount","slug":"wordcount","permalink":"https://hexuezhi.github.io/tags/wordcount/"},{"name":"CentOS","slug":"CentOS","permalink":"https://hexuezhi.github.io/tags/CentOS/"},{"name":"JDK","slug":"JDK","permalink":"https://hexuezhi.github.io/tags/JDK/"},{"name":"MySQL","slug":"MySQL","permalink":"https://hexuezhi.github.io/tags/MySQL/"},{"name":"公式","slug":"公式","permalink":"https://hexuezhi.github.io/tags/%E5%85%AC%E5%BC%8F/"},{"name":"私链搭建","slug":"私链搭建","permalink":"https://hexuezhi.github.io/tags/%E7%A7%81%E9%93%BE%E6%90%AD%E5%BB%BA/"},{"name":"水龙头合约","slug":"水龙头合约","permalink":"https://hexuezhi.github.io/tags/%E6%B0%B4%E9%BE%99%E5%A4%B4%E5%90%88%E7%BA%A6/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://hexuezhi.github.io/tags/MongoDB/"},{"name":"图床应用","slug":"图床应用","permalink":"https://hexuezhi.github.io/tags/%E5%9B%BE%E5%BA%8A%E5%BA%94%E7%94%A8/"},{"name":"测试","slug":"测试","permalink":"https://hexuezhi.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Nunpy","slug":"Nunpy","permalink":"https://hexuezhi.github.io/tags/Nunpy/"}]}
{"meta":{"title":"何小智の博客","subtitle":"时间是人类发展的空间。","description":null,"author":"RenKeXZ","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404","date":"2020-06-05T11:34:59.542Z","updated":"2020-01-02T14:52:29.140Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"about","date":"2020-01-01T10:02:17.000Z","updated":"2020-06-05T11:34:25.367Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"If a man works only for himself, he may become a famous scholar, a brilliant intellectual, but he can never be a real perfect man."},{"title":"","date":"2020-06-05T13:21:15.800Z","updated":"2020-06-05T13:21:15.800Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-06-08T06:57:25.323Z","updated":"2020-06-08T06:57:25.323Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LeetCode148、排序链表","slug":"LeetCode148","date":"2020-09-05T08:13:17.347Z","updated":"2020-09-05T12:33:29.783Z","comments":true,"path":"2020/09/05/LeetCode148/","link":"","permalink":"http://yoursite.com/2020/09/05/LeetCode148/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/sort-list/ 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 思想： 先对链表进行分割，然后再归并排序。 解法：1234567891011121314151617181920212223242526272829303132class Solution: def sortList(self, head: ListNode) -&gt; ListNode: if not head or not head.next: return head #应用快慢指针得到链表的中间节点 slow, fast = head, head.next while fast and fast.next: slow = slow.next fast = fast.next.next #将链表从中间切割开，分为head和mid两个链表 mid,slow.next = slow.next, None #获取排序后的head和mid left,right = self.sortList(head), self.sortList(mid) #采用哨兵节点 h = res = ListNode(0) #合并两个有序链表 while left and right: if left.val&lt;right.val: h.next = left left = left.next else: h.next = right right = right.next h = h.next #剩下的链表直接加到末尾 h.next = left if left else right return res.next","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"二分法","slug":"二分法","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"归并排序","slug":"归并排序","permalink":"http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/%E9%80%92%E5%BD%92/"},{"name":"快慢指针","slug":"快慢指针","permalink":"http://yoursite.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"哨兵","slug":"哨兵","permalink":"http://yoursite.com/tags/%E5%93%A8%E5%85%B5/"}]},{"title":"获取用户任务列表报500BUG","slug":"用户任务列表报500BUG","date":"2020-09-04T07:05:19.444Z","updated":"2020-09-05T08:57:25.003Z","comments":true,"path":"2020/09/04/用户任务列表报500BUG/","link":"","permalink":"http://yoursite.com/2020/09/04/%E7%94%A8%E6%88%B7%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8%E6%8A%A5500BUG/","excerpt":"公司人员报告了获取任务列表为500的bug，但是我们测试数据却能正常返回。玄学？NO!NO!NO!","text":"公司人员报告了获取任务列表为500的bug，但是我们测试数据却能正常返回。玄学？NO!NO!NO! BUG情况公司人员报告了一个bug，获取我们用户任务列表的接口数据时会出现500的异常。但是经过我们自己测试没有发现问题。 几天后，公司人员又发来了截图，表示获取任务列表又出现了500异常。并且测试过后发现只有userid是6的才会出现500异常，其他userid不会出现，并且userid为6的用户调用这个接口，时而能够正常返回数据，时而又出现500bug。 原因经过查看项目log发现程序运行过程中出现了空指针异常。并且定位到相关的代码行。 1long sl = user.getFinishTime().getTime() - user.getCreateTime().getTime(); （不要问为什么任务的变量名是user，我也不知道。。。）小伙伴写这段代码时是通过获取到任务的finishTime，再拿finishTime减去createTime。 初步猜想可能是新创建的任务没有finish，导致获取到的finishTime为null。因此引发空指针异常。 而当用户的任务完成时，finishTime被填上，再获取任务列表时，又可以正常获取到数据。 又因为公司那边测试一直用的是同一个用户id（6），所以每次创建任务之后获取任务列表，显示是500.其他用户id并没有运行任务，所以表象是只有userid为6的用户才会发生异常。 进一步查看log，佐证了自己的猜想。 500bug log显示在查询用户列表之前，用户新创建了一个任务。 总结虽问题不是什么大问题，代码也不是自己写的，但有两点须引以为戒。 变量名的规范：任务记录的对象，命名为user，让我在定位bug的时候，理解代码出现了偏差。所以变量命名规范，有助于对代码快速的理解，从而能够更快的定位bug。 注释：太重要了！！！如果不写注释，等出现bug再定位的时候，再次读即使是自己写的代码，也会耗费些时间来理解。","categories":[{"name":"bug","slug":"bug","permalink":"http://yoursite.com/categories/bug/"}],"tags":[{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"}]},{"title":"docker部署nginx+tomcat","slug":"docker部署nginx+tomcat","date":"2020-09-03T13:10:08.815Z","updated":"2020-09-05T12:33:38.941Z","comments":true,"path":"2020/09/03/docker部署nginx+tomcat/","link":"","permalink":"http://yoursite.com/2020/09/03/docker%E9%83%A8%E7%BD%B2nginx+tomcat/","excerpt":"以docker方式启动tomcat+nginx。","text":"以docker方式启动tomcat+nginx。 一、tomcat新建tomcat文件夹，可以放入自己的应用。 1234567mkdir tomcatcd tomcatmkdir appcd apptouch index.htmlecho &lt;h1&gt;helloworld&lt;/h1&gt; &gt;index.htmlcd .. 拉取镜像，并建立开启容器(注意这里并不用开启8080端口映射)： 12docker pull tomcatdockers run -id --name myTomcat -v $PWD:/usr/local/tomcat/webapps tomcat 查看容器ip： 1docker inspect myTomcat | grep \"IPAddress\" 假设这里查到的是172.17.0.3 二、nginx首先服务器防火墙开启80端口： 12firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --reload 新建nginx文件夹，并新建nginx.conf 1234mkdir nginxcd nginxtouch nginx.confvim nginx.comf 填入nginx.conf的内容，注意http-&gt;server-&gt;location-&gt;proxy_pass。修改为上一步查到的ip。 注意：这里不能填入宿主机的ip。（因为tomcat默认并不是以host模式开启，而是以桥接模式开启） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; location / &#123; root html; proxy_pass http://172.17.0.3:8080; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 拉取镜像，并建立开启容器： 12docker pull nginxdocker run -d --name myNginx -p 80:80 nginx 将之前写的配置文件复制到容器中，并重启容器： 12docker cp nginx.conf nginx:/etc/nginx/nginx.confdocker restart nginx 三、测试访问http://服务器ip/app","categories":[{"name":"以太坊","slug":"以太坊","permalink":"http://yoursite.com/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"docker启动以太坊私链","slug":"docker启动以太坊私链","date":"2020-09-01T12:27:08.059Z","updated":"2020-09-05T12:37:45.818Z","comments":true,"path":"2020/09/01/docker启动以太坊私链/","link":"","permalink":"http://yoursite.com/2020/09/01/docker%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/","excerpt":"以docker方式启动以太坊私链，并部署Dapp。","text":"以docker方式启动以太坊私链，并部署Dapp。 一、查看防火墙状态首先查看主机防火墙是否开启，如果已开启，需要开放8545端口，用于外界通过rpc方式访问私链。 查看防火墙状态： 1systemctl status firewalld.service 防火墙状态 开放方法： 12firewall-cmd --zone=public --add-port=8545/tcp --permanentfirewall-cmd --reload 二、创建链码在workspace下，新建/code/chain/mychain文件夹，创建genesis.json。 路径 chainId：以太坊的链的id，可以自己随便取值，但是需要注意搭建私链时，这个值不能与以太坊主网或者是测试网的chainId相同。以太坊chainId查询 genesis.json： 123456789101112131415161718192021222324252627&#123; &quot;config&quot;: &#123; &quot;chainId&quot;: 666, &quot;homesteadBlock&quot;: 0, &quot;eip150Block&quot;: 0, &quot;eip150Hash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;eip155Block&quot;: 0, &quot;eip158Block&quot;: 0, &quot;byzantiumBlock&quot;: 0, &quot;constantinopleBlock&quot;: 0, &quot;petersburgBlock&quot;: 0, &quot;istanbulBlock&quot;: 0, &quot;ethash&quot;: &#123;&#125; &#125;, &quot;nonce&quot;: &quot;0x0&quot;, &quot;timestamp&quot;: &quot;0x5ddf8f3e&quot;, &quot;extraData&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;gasLimit&quot;: &quot;0x47b760&quot;, &quot;difficulty&quot;: &quot;0x00002&quot;, &quot;mixHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;coinbase&quot;: &quot;0x0000000000000000000000000000000000000000&quot;, &quot;alloc&quot;: &#123; &#125; &#125;, &quot;number&quot;: &quot;0x0&quot;, &quot;gasUsed&quot;: &quot;0x0&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;&#125; 三、拉取image1docker pull ethereum/client-go 四、创建容器123docker run -it --network=host --name mychain -v /workspace:/workspace --entrypoint /bin/sh ethereum/client-go#或者docker run -it --name mychain -p 8545:8545 -v /workspace:/workspace --entrypoint /bin/sh ethereum/client-go 参数说明： -i：打开STDIN，用于控制台交互，常与-t一起使用 -t：分配tty设备，支持终端登陆，默认为false，常与-i一起使用 --network=host：将容器的网络模式设置为host模式，即用宿主机的ip和端口进行外部通信 -p 8545:8545：将宿主机的8545端口映射到dockers容器的8545端口上 --rm：指定容器停止后自动删除容器（不支持以docker run -d启动的容器 ） -v：给容器挂载存储卷，挂载到容器的某个目录，这里讲本地的/workspace挂载到了容器的/workspace目录，用来在容器和宿主机之间共享文件 --entrypoint：覆盖image的入口点，ubuntu环境下docker默认入口点其实是/bin/bash，修改默认入口点是为了不让节点自动运行，稍后会对节点进行自定义配置使其成为私有链节点 此后启动容器就可以，直接通过 1docker start -i mychain 五、启动私链经过上面的命令，此时命令行提示符已经转变。进入之前创建的/workspace/code/chain/mychain文件夹下，初始化链json 1geth --datadir . init genesis.json 启动私链，networkid和rpcaddr的设置方法同开发者模式。查看输出日志output.log同上。 1geth --datadir . --nodiscover --networkid 1234 --rpc --rpccorsdomain &quot;*&quot; --rpcaddr 0.0.0.0 --rpcport 8545 console --allow-insecure-unlock 2&gt;output.log 注意：搭建私链后一定要进行以下测试，看是否能够正常发起交易。","categories":[{"name":"以太坊","slug":"以太坊","permalink":"http://yoursite.com/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"以太坊合约交易inputData解码","slug":"以太坊合约交易inputData解码","date":"2020-09-01T02:20:24.016Z","updated":"2020-09-05T12:37:10.138Z","comments":true,"path":"2020/09/01/以太坊合约交易inputData解码/","link":"","permalink":"http://yoursite.com/2020/09/01/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%90%88%E7%BA%A6%E4%BA%A4%E6%98%93inputData%E8%A7%A3%E7%A0%81/","excerpt":"以太坊每笔交易中都有InputData，本项目主要是识别合约交易中的InputData。","text":"以太坊每笔交易中都有InputData，本项目主要是识别合约交易中的InputData。 一、需求式例交易hash：0xb1c0abd217193ffe64f97caedad8fa6f0f9c0265967d2ab9fb782280c928fb47 inputdata 需要将交易中的数据解码为上图中的数据。 二、思路 先通过web3来取得交易中的to地址和inputdata。 将to地址传入erherScan的api获得合约的abi。 通过abi-decoder来解析inputdata。 三、具体实现项目地址：https://github.com/HeXueZhi/DecodeInputData 整体通过webpack框架。应用的包：package.json文件中的dependencies 3.1 实例化web3在infura注册一个key，替换代码中的key。（Infura提供免费的以太坊节点RPC API服务） 1234567891011121314151617181920212223window.addEventListener('load', function() &#123; if (typeof web3 !== 'undefined') &#123; window.web3 = new Web3(web3.currentProvider); &#125; else &#123; var web3Provider; if (window.ethereum) &#123; web3Provider = window.ethereum; try &#123; // 请求用户授权 window.ethereum.enable(); &#125; catch (error) &#123; // 用户不授权时 console.error(\"User denied account access\") &#125; &#125; else if (window.web3) &#123; // 老版 MetaMask Legacy dapp browsers... web3Provider = window.web3.currentProvider; &#125; else &#123; web3Provider = new Web3.providers.HttpProvider('https://mainnet.infura.io/v3/填入infura个人的key'); &#125; web3 = new Web3(web3Provider); &#125; // App.start();&#125;); 3.2 解析inputdata在etherscan注册apikey，替换代码中的。 如果不想注册删掉代码中的&amp;apikey=填入etherscan的个人key也可以，不过etherscan会添加每秒限制访问5次的限制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import \"./app.css\";import &#123; default as Web3&#125; from 'web3';var web3;var ABI;const fetch = require('node-fetch');//通过fetch获取abiconst abiDecoder = require('abi-decoder'); // 通过abi解析inputdatawindow.App = &#123; getInputData: function()&#123; document.getElementById(\"textArea\").value = \"\"; document.getElementById(\"textArea2\").value = \"\"; var TXHash = document.getElementById(\"TXHash\").value; if (TXHash != null)&#123; console.log(TXHash); var inputData; web3.eth.getTransaction(TXHash,function(err, accs) &#123; if (err != null) &#123; alert(\"There was an error fetching your TX.\"); return; &#125; if (accs.length == 0) &#123; alert(\"Couldn't get any accounts! Make sure your Ethereum client is configured correctly.\"); return; &#125; console.log(accs.input);//输出inputdata //验证to地址是否是合约地址，合约地址的Code不为空 web3.eth.getCode(accs.to, function(err, accs)&#123; if(accs === '0x') &#123; alert('普通转账交易'); return; &#125; &#125;); var contractAddress = accs.to; if (contractAddress != null)&#123; var url = 'https://api-cn.etherscan.com/api?module=contract&amp;action=getabi&amp;address=' + contractAddress + '&amp;apikey=填入etherscan的个人key'; fetch(url, &#123;method: 'get',&#125;).then(response =&gt; response.json().then(data =&gt; &#123; ABI = JSON.parse(data.result);//获取合约abi' // console.log(ABI); document.getElementById(\"textArea\").value = JSON.stringify(JSON.parse(data.result),null, ' '); abiDecoder.addABI(ABI);//解析abi var decodedData = abiDecoder.decodeMethod(accs.input);//获得解析数据 document.getElementById(\"textArea2\").value = JSON.stringify(decodedData,null,' '); &#125;)); &#125;else&#123; alert(\"error: ContractAddress为null!!!\"); return; &#125; &#125;); &#125;else&#123; alert(\"error: TXHash为null!!!\"); return; &#125; &#125;&#125;; 3.3 build项目在文件夹下执行: 1npm run build 3.4 启动项目在文件夹下执行: 1npm run dev 访问http://localhost:8080即可。 项目截图","categories":[{"name":"以太坊","slug":"以太坊","permalink":"http://yoursite.com/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"以太坊","slug":"以太坊","permalink":"http://yoursite.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"inputData","slug":"inputData","permalink":"http://yoursite.com/tags/inputData/"}]},{"title":"LeetCode332、重新安排行程","slug":"LeetCode332","date":"2020-08-27T02:13:22.157Z","updated":"2020-09-05T12:34:08.878Z","comments":true,"path":"2020/08/27/LeetCode332/","link":"","permalink":"http://yoursite.com/2020/08/27/LeetCode332/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/reconstruct-itinerary/ 错误思想： 首先将列表转换为字典，在插入过程中将字典中的value排序。（这一步思想是对的） 然后从”JFK”开始遍历，每次取dict[&quot;x&quot;][0]保证字典序。 错误原因： [[&quot;JFK&quot;,&quot;KUL&quot;],[&quot;JFK&quot;,&quot;NRT&quot;],[&quot;NRT&quot;,&quot;JFK&quot;]] NRT节点会访问不到 错误解法：123456789101112131415161718192021222324252627class Solution: def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]: if not tickets: return [] #构建location字典 location = collections.defaultdict(list) for ticket in tickets: if len(location[ticket[0]])!=0: i = 0 while i&lt;len(location[ticket[0]]): if location[ticket[0]][i] &gt; ticket[1]: break i += 1 location[ticket[0]].insert(i,ticket[1]) else: location[ticket[0]].append(ticket[1]) #遍历 res = [\"JFK\"] res.append(location[\"JFK\"][0]) location[\"JFK\"].pop(0) for _ in range(len(tickets)-1): if len(location[res[-1]]) !=0: res.append(location[res[-1]][0]) location[res[-2]].pop(0) return res 正确思想： 欧拉通路：通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。 欧拉回路：通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。 欧拉图：具有欧拉回路的无向图称为欧拉图。 半欧拉图：具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。 当我们贪心地选择字典序最小的节点前进时，我们可能先走入「死胡同」，从而导致无法遍历到其他还未访问的边。于是我们希望能够遍历完当前节点所连接的其他节点后再进入「死胡同」。 正确解法：12345678910111213141516171819202122class Solution: def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]: if not tickets: return [] #利用小根堆排序 vec = collections.defaultdict(list) for fr,to in tickets: vec[fr].append(to) for key in vec.keys(): heapq.heapify(vec[key]) print(vec) #节点会倒序入栈 def dfs(curr): while vec[curr]: tem = heapq.heappop(vec[curr]) dfs(tem) stack.append(curr) stack = [] dfs(\"JFK\") return stack[::-1]","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"欧拉回路","slug":"欧拉回路","permalink":"http://yoursite.com/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"},{"name":"欧拉通路","slug":"欧拉通路","permalink":"http://yoursite.com/tags/%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF/"},{"name":"Hierholzer算法","slug":"Hierholzer算法","permalink":"http://yoursite.com/tags/Hierholzer%E7%AE%97%E6%B3%95/"}]},{"title":"LeetCode459、重复的字符串","slug":"LeetCode459","date":"2020-08-24T07:46:26.333Z","updated":"2020-09-05T12:34:19.887Z","comments":true,"path":"2020/08/24/LeetCode459/","link":"","permalink":"http://yoursite.com/2020/08/24/LeetCode459/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/repeated-substring-pattern/ 重复的字符串需要满足四个条件： 总串长度是子串长度的n倍，即总串长度能够整除子串长度 子串是总串的前缀 s[子串长度]=s[0],s[子串长度+1]=s[1]…… 子串长度小于等于总串长度的一半 解法：12345678910111213class Solution: def repeatedSubstringPattern(self, s: str) -&gt; bool: sLen = len(s) for i in range(1,sLen//2+1): match = True if sLen % i == 0: for j in range(i,sLen): if s[j]!=s[j-i]: match = False break if match: return True return False","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"LeetCode529、扫雷游戏","slug":"LeetCode529","date":"2020-08-20T04:04:30.836Z","updated":"2020-09-05T12:34:24.921Z","comments":true,"path":"2020/08/20/LeetCode529/","link":"","permalink":"http://yoursite.com/2020/08/20/LeetCode529/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/minesweeper/ “M”表示地雷。 “E”表示未挖出的空方块 “B”表示已经挖出来的空方块，且周围8个方块不存在地雷 “数字1-8”表示放个周围有多少个地雷 解法1：dfs1234567891011121314151617181920212223242526272829303132333435class Solution: def updateBoard(self, board: List[List[str]], click: List[int]) -&gt; List[List[str]]: array1 = [0,1,1,1,0,-1,-1,-1] array2 = [1,1,0,-1,-1,-1,0,1] m = len(board) n = len(board[0]) # print(m,n) def dfs(x,y): num = 0 for i in range(8): newX = x + array1[i] newY = y + array2[i] if not (0&lt;=newX&lt;m and 0&lt;=newY&lt;n) or board[newX][newY]=='B': continue if board[newX][newY] == 'M': num += 1 if num&gt;0: board[x][y] = str(num) else: board[x][y] = 'B' for j in range(8): newX1 = x + array1[j] newY2 = y + array2[j] # print(newX1,newY2) # print(not 0&lt;=newX1&lt;m or not 0&lt;=newY2&lt;n) if not(0&lt;=newX1&lt;m and 0&lt;=newY2&lt;n) or board[newX1][newY2]!='E': continue dfs(newX1,newY2) if board[click[0]][click[1]]=='M': board[click[0]][click[1]] = 'X' else: dfs(click[0],click[1]) return board 解法2：bfs注意：一定要有visit数组，如果没有的话，可能会加入重复节点进入队列中。 下图中绿色边框，橙色填充的节点为重复入队的节点。 示例图 123456789101112131415161718192021222324252627282930313233343536373839404142array1 = [0,1,1,1,0,-1,-1,-1] array2 = [1,1,0,-1,-1,-1,0,1] m = len(board) n = len(board[0]) queue = collections.deque() queue.append(click) visit = [[False for _ in range(n)] for _ in range(m)] visit[click[0]][click[1]] = True def bfs(): while queue: node = queue.popleft() x = node[0] y = node[1] num = 0 for i in range(8): newX = x + array1[i] newY = y + array2[i] if not (0&lt;=newX&lt;m and 0&lt;=newY&lt;n): continue if board[newX][newY] == 'M': num += 1 if num&gt;0: board[x][y] = str(num) else: board[x][y]='B' for j in range(8): newX1 = x + array1[j] newY2 = y + array2[j] # print(newX1,newY2) # print(not 0&lt;=newX1&lt;m or not 0&lt;=newY2&lt;n) if not(0&lt;=newX1&lt;m and 0&lt;=newY2&lt;n) or board[newX1][newY2]!='E' or visit[newX1][newY2]==True: continue queue.append([newX1,newY2]) visit[newX1][newY2] = True if board[click[0]][click[1]]=='M': board[click[0]][click[1]] = 'X' else: bfs() return board","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://yoursite.com/tags/bfs/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"}]},{"title":"LeetCode647、回文子串","slug":"LeetCode647","date":"2020-08-19T08:27:49.587Z","updated":"2020-09-05T12:34:13.955Z","comments":true,"path":"2020/08/19/LeetCode647/","link":"","permalink":"http://yoursite.com/2020/08/19/LeetCode647/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/palindromic-substrings/ 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 解法1：暴力思想：每个位置都以它为中心求回文。 奇数回文的解决方法：x==y 偶数回文的解决方法：y = x + i % 2 遍历范围：2*size-1 编号i 回文中心左起始位置x 回文中心右起始位置y 0 0 0 1 0 1 2 1 1 3 1 2 4 2 2 5 2 3 6 3 3 123456789101112class Solution: def countSubstrings(self, s: str) -&gt; int: result = 0 size = len(s) for i in range(2*size-1): x = i//2 y = x + i % 2 while x&gt;=0 and y&lt;size and s[x] == s[y]: x-=1 y+=1 result += 1 return result 解法2：manachemanache算法详解：https://ethsonliu.com/2018/04/manacher.html 12345678910111213141516171819class Solution: def countSubstrings(self, s: str) -&gt; int: node = \"#\" s = node.join(s) s = \"$#\" + s + \"#!\" print(s) n = len(s) f = [0 for _ in range(n)] iMax = rMax = ans = 0 for i in range(1,n-1): f[i] = 1 if i&gt;rMax else min(rMax-i+1,f[2 * iMax - i]) while s[i+f[i]]==s[i-f[i]]: f[i]+=1 if i+f[i]-1&gt;rMax: iMax = i rMax = i + f[i] -1 ans += (f[i]//2) return ans","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"暴力","slug":"暴力","permalink":"http://yoursite.com/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"manacher","slug":"manacher","permalink":"http://yoursite.com/tags/manacher/"}]},{"title":"LeetCode108and109、有序结构构建平衡二叉搜索树","slug":"LeetCode108and109","date":"2020-08-18T04:56:29.028Z","updated":"2020-09-05T12:35:16.021Z","comments":true,"path":"2020/08/18/LeetCode108and109/","link":"","permalink":"http://yoursite.com/2020/08/18/LeetCode108and109/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/ 取mid=(left+right)//2，(left,mid-1)构建左子树，(mid+1,right)构建右子树。 解法：分治123456789101112class Solution: def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode: def buildTree(left,right): if left&gt;right: return None mid = (left+right)//2 root = TreeNode() root.val = nums[mid] root.left = buildTree(left,mid-1) root.right = buildTree(mid+1,right) return root return buildTree(0,len(nums)-1) LeetCode109、将有序链表转换二叉搜索树解法1：分治每次遍历列表找到mid节点 123456789101112131415161718192021class Solution: def sortedListToBST(self, head: ListNode) -&gt; TreeNode: def findMid(left,right): slow = left fast = left while fast != right and fast.next != right: slow = slow.next fast = fast.next.next return slow def buildTree(left,right): if left == right: return None mid = findMid(left,right) root = TreeNode() root.val = mid.val root.left = buildTree(left,mid) root.right = buildTree(mid.next,right) return root return buildTree(head,None) 解法2：分治利用中序遍历，延迟填入节点中的值。 1234567891011121314151617181920212223class Solution: def sortedListToBST(self, head: ListNode) -&gt; TreeNode: def getLength(head): num = 0 p = head while p: num += 1 p = p.next return num def buildTree(left,right): if left&gt;right: return None mid = (left+right)//2 root = TreeNode() root.left = buildTree(left,mid-1) nonlocal head root.val = head.val head = head.next root.right = buildTree(mid+1,right) return root return buildTree(0,getLength(head)-1)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"分治","slug":"分治","permalink":"http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"}]},{"title":"基于以太坊私链的溯源Dapp","slug":"以太坊溯源Dapp","date":"2020-08-15T09:58:10.027Z","updated":"2020-09-05T12:37:27.352Z","comments":true,"path":"2020/08/15/以太坊溯源Dapp/","link":"","permalink":"http://yoursite.com/2020/08/15/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%BA%AF%E6%BA%90Dapp/","excerpt":"帮助老师撰写以太坊课程的实验指导书，因此需要设计一个基于以太坊私链的溯源Dapp项目。","text":"帮助老师撰写以太坊课程的实验指导书，因此需要设计一个基于以太坊私链的溯源Dapp项目。 项目源码：https://github.com/HeXueZhi/FoodTransportation 实验环境： win10：用于创建Dapp CentOS7：用于搭建私链 一、私链的创建前面的文章有写如何搭建私链。 以太坊搭建私链 二、以太坊Dapp的创建Dapp整体基于truffle，前端采用webpack打包。 2.1 编写合约合约编写以及编译采用remix（需要较好的网络环境），推荐使用老版本界面。remix入门 合约代码： 12345678910111213141516171819202122232425262728293031323334353637pragma solidity &gt;&#x3D;0.4.22 &lt;0.7.0;contract FoodTransportation&#123; struct Location&#123; string locationName; string transPerson; uint timeStamp; &#125; string foodName; mapping (uint &#x3D;&gt; Location) trail; uint8 locationNum; function addNewLocation(string memory food,string memory locationName,string memory transPerson)public&#123; if(bytes(foodName).length &#x3D;&#x3D; 0)&#123; foodName &#x3D; food; &#125; Location memory newLocation; newLocation.locationName &#x3D; locationName; newLocation.transPerson &#x3D; transPerson; newLocation.timeStamp &#x3D; now; trail[locationNum] &#x3D; newLocation; locationNum++; &#125; function getLocationNum() public view returns(uint8)&#123; return locationNum; &#125; function getFoodName() public view returns(string memory)&#123; return foodName; &#125; function getLocation(uint8 locationNo) public view returns(string memory,string memory,uint)&#123; return (trail[locationNo].locationName,trail[locationNo].transPerson,trail[locationNo].timeStamp); &#125;&#125; 这一步需要完成合约的编译和测试。 2.2 环境准备win10系统中，安装node、truffle、ganache-cli。 执行truffle version查看版本。 truffle version 尤其需要注意solidity和web3的版本。版本不同语法支持也不同，所以安装时，尽量选择于上图中相差不多的版本。 2.3 truffle+webpack创建项目 新建Dapp/FoodTransportation文件夹 文件夹下执行： 1truffle unbox webpack 此命令会下载truffle提供的官方示例，下载时间可能会有点长，耐心等待。下载完成后的提示以及目录结构如下图所示。 此示例项目的运行启动：留个坑。 修改truffle-config.js为： 12345678910require('babel-register')module.exports = &#123; networks: &#123; development: &#123; host: 'localhost', port: 8545, network_id: '*' // Match any network id &#125; &#125;&#125; 本文件夹下的powershell中执行： 1npm install babel-register 删除contracts文件夹中的ConvertLib.sol和MetaCoin.sol文件，创建FoodTransportation.sol合约文件，复制刚才编写的合约代码。 修改migrations文件夹中的2_deploy_contracts.js文件。 注意：这里直接删除这个文件也无妨，因为本项目使用web3来部署合约，不需要使用truffle migrate命令帮助部署合约。 12345const FoodTransportation = artifacts.require(\"./FoodTransportation\");module.exports = function(deployer) &#123; deployer.deploy(FoodTransportation);&#125;; powershell中执行truffle compile命令。truffle中自带的solc-js会对合约进行编译。在Dapp文件夹下会出现build文件夹，存放编译形成的json文件。 在Dapp的app文件夹下粘贴写好的html文件，src目录下粘贴需要的js文件和css文件。 修改webpack-config.js 1234567891011121314151617181920212223242526272829303132333435const path = require('path');const CopyWebpackPlugin = require('copy-webpack-plugin');module.exports = &#123; entry: './src/app.js', output: &#123; path: path.resolve(__dirname, 'build'), filename: 'app.js' &#125;, mode : 'development', plugins: [ // Copy our app's index.html to the build folder. new CopyWebpackPlugin([ &#123; from: './index.html', to: \"index.html\" &#125; ]) ], module: &#123; rules: [ &#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, &#123; test: /\\.json$/, exclude: /(node_modules|bower_components)/, use: 'json-loader' &#125;, &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, loader: 'babel-loader', query: &#123; presets: ['es2015'], plugins: ['transform-runtime'] &#125; &#125; ] &#125;&#125; 在app目录下执行： 12345678npm install web3@0.18.4 --save-devnpm install webpack --save-devnpm install style-loader css-loader json-loader --save-devnpm install -D babel-loader@7 babel-core babel-preset-env --save-devnpm install babel-preset-es2015 --save-devnpm install babel-plugin-transform-runtime --save-devnpm run buildnpm run dev 进入http://localhost:8080查看界面。注意：现在如果没有启动私链，页面由于没有获取到账户，会发出警告，启动私链，连接metamask刷新即可。 三、合约部署3.1 win10本地ganache测试 安装ganache-cli 1npm install -g ganache-cli 执行ganache-cli 在谷歌浏览器中安装metamask插件，安装好后，先在metamask右上角选择localhost:8545网络，然后选择助记词恢复钱包账户。 然后在Dapp/app执行npm run dev，打开浏览器的http://localhost:8080/ 按F12，查看console界面。 测试项目。 3.2 CentOS私链测试 开启私链，如无账户，先创建账户personal.newAccount()，输入密码。 开始挖矿。miner.start(1) 查看账户余额eth.getBalance(eth.accounts[0])，为了保证能够发起合约部署等交易，需要一些ETH。 设置虚拟机防火墙，打开8545端口。CentOS设置防火墙 metamask连接CentOS的私链。需要新创建rpc网络。 rpc地址：http://192.168.2.151:8545，ip填虚拟机ip就可以。 chainID：填入genesis.json中的chainid即可。 切换至刚创建的网络，并导入账户。通过虚拟机私链文件夹下的keystore文件夹下的json文件导入到metamask即可。 导入账户之后刷新http://localhost:8080，再点击metamask，就能够连接刚刚导入的账户了。 项目截图 测试项目。 测试完成后执行miner.stop()停止挖矿。","categories":[{"name":"以太坊","slug":"以太坊","permalink":"http://yoursite.com/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"以太坊","slug":"以太坊","permalink":"http://yoursite.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"Dapp","slug":"Dapp","permalink":"http://yoursite.com/tags/Dapp/"},{"name":"truffle","slug":"truffle","permalink":"http://yoursite.com/tags/truffle/"}]},{"title":"LeetCode130、被围绕的区域","slug":"LeetCode130","date":"2020-08-12T00:34:28.892Z","updated":"2020-09-05T12:34:38.660Z","comments":true,"path":"2020/08/12/LeetCode130/","link":"","permalink":"http://yoursite.com/2020/08/12/LeetCode130/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/surrounded-regions/ 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 因此可以遍历列表，将能够与边界上’O’相连的’O’标记出来，剩下的未被标记的’O’即为需要改变的。 解法1：dfs12345678910111213141516171819202122232425262728293031class Solution: def solve(self, board: List[List[str]]) -&gt; None: if not board: return m = len(board) n = len(board[0]) def dfs(x,y): if not 0&lt;=x&lt;m or not 0&lt;=y&lt;n or board[x][y] != \"O\": return board[x][y] = \"A\" dfs(x+1,y) dfs(x-1,y) dfs(x,y+1) dfs(x,y-1) for i in range(m): dfs(i,0) dfs(i,n-1) for j in range(n): dfs(0,j) dfs(m-1,j) for i in range(m): for j in range(n): if board[i][j] == \"A\": board[i][j] = \"O\" elif board[i][j]==\"O\": board[i][j] = \"X\" 解法2：bfs123456789101112131415161718192021222324252627282930313233343536373839class Solution: def solve(self, board: List[List[str]]) -&gt; None: \"\"\" Do not return anything, modify board in-place instead. \"\"\" #BFS if not board: return m = len(board) n = len(board[0]) queue = collections.deque() for i in range(m): if board[i][0]==\"O\": queue.append((i,0)) if board[i][n-1]==\"O\": queue.append((i,n-1)) for j in range(n): if board[0][j]==\"O\": queue.append((0,j)) if board[m-1][j]==\"O\": queue.append((m-1,j)) while queue: x,y = queue.popleft() board[x][y] = \"A\" for mx, my in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]: if 0 &lt;= mx &lt; m and 0 &lt;= my &lt; n and board[mx][my] == \"O\": queue.append((mx, my)) for i in range(m): for j in range(n): if board[i][j] == \"A\": board[i][j] = \"O\" elif board[i][j]==\"O\": board[i][j] = \"X\"","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://yoursite.com/tags/bfs/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"}]},{"title":"LeetCode207、课程表","slug":"LeetCode207","date":"2020-08-04T02:47:48.951Z","updated":"2020-09-05T12:34:34.390Z","comments":true,"path":"2020/08/04/LeetCode207/","link":"","permalink":"http://yoursite.com/2020/08/04/LeetCode207/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/course-schedule/ 解法1：拓扑排序、bfs通过拓扑排序判断图中是否存在环路。 构建有向边的邻接矩阵edge和每个节点的入度表indegree. 从入度为0的节点开始遍历，遍历到一个节点，此节点的入读数减1，入度为0时加入queue。 如无环，每个节点都会入队和出队，则每次出队numCourse--,最后判断其是否为0. 123456789101112131415161718192021222324from collections import dequeclass Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool: indegree = [0 for _ in range(numCourses)] edge = [[] for _ in range(numCourses)] for pre in prerequisites: indegree[pre[0]] += 1 edge[pre[1]].append(pre[0]) print(indegree) print(edge) queue = deque() for i in range(len(indegree)): if not indegree[i]: queue.append(i) while queue: node = queue.popleft() numCourses -= 1 for v in edge[node]: indegree[v] -= 1 if not indegree[v]: queue.append(v) return numCourses==0 解法2：拓扑排序、dfs用flags数组来保存当前节点的状态： 0：没被访问过 -1：已经被访问过 1：在当前遍历中访问过（表示存在环路） 12345678910111213141516171819class Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool: flags = [0 for _ in range(numCourses)] edge = [[] for _ in range(numCourses)] for pre in prerequisites: edge[pre[1]].append(pre[0]) def dfs(i,edge,flags): if flags[i]==-1: return True if flags[i]==1: return False flags[i] = 1 for v in edge[i]: if not dfs(v,edge,flags): return False flags[i] = -1 return True for i in range(numCourses): if not dfs(i,edge,flags): return False return True","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"bfs","slug":"bfs","permalink":"http://yoursite.com/tags/bfs/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://yoursite.com/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"}]},{"title":"LeetCode179、最大数","slug":"LeetCode179","date":"2020-07-31T06:44:55.655Z","updated":"2020-09-05T12:35:01.038Z","comments":true,"path":"2020/07/31/LeetCode179/","link":"","permalink":"http://yoursite.com/2020/07/31/LeetCode179/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/largest-number/ image-20200731144650252 python解法：12345678class LargerNumKey(str): def __lt__(self, other): return self+other &gt; other+self class Solution: def largestNumber(self, nums): largest_num = ''.join(sorted(map(str, nums), key=LargerNumKey)) return '0' if largest_num[0] == '0' else largest_num 首先LargerNumKey继承了str类，实现了富比较方法。 3，30比较：self=30，other=3，返回False，不交换位置。 java解法：1234567891011121314151617181920212223242526272829303132333435class Solution &#123; private class LargerNumberComparator implements Comparator&lt;String&gt; &#123; @Override public int compare(String a, String b) &#123; String order1 = a + b; String order2 = b + a; return order2.compareTo(order1); &#125; &#125; public String largestNumber(int[] nums) &#123; // Get input integers as strings. String[] asStrs = new String[nums.length]; for (int i = 0; i &lt; nums.length; i++) &#123; asStrs[i] = String.valueOf(nums[i]); &#125; // Sort strings according to custom comparator. Arrays.sort(asStrs, new LargerNumberComparator()); // If, after being sorted, the largest number is `0`, the entire number // is zero. if (asStrs[0].equals(\"0\")) &#123; return \"0\"; &#125; // Build largest number from sorted array. String largestNumberStr = new String(); for (String numAsStr : asStrs) &#123; largestNumberStr += numAsStr; &#125; return largestNumberStr; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"LeetCode187、重复的DNA序列","slug":"LeetCode187","date":"2020-07-31T02:15:38.282Z","updated":"2020-09-05T12:34:49.365Z","comments":true,"path":"2020/07/31/LeetCode187/","link":"","permalink":"http://yoursite.com/2020/07/31/LeetCode187/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/repeated-dna-sequences/ 解法一：滑动窗口暴力法解法二：滑动窗口+hash将string映射为nums数组，每10位数计算为4进制数作为hash值存入set（）中，如果在hash在set中，则表示子串重复，将子串存入set（）中。 123456789101112131415161718192021222324class Solution: def findRepeatedDnaSequences(self, s: str) -&gt; List[str]: L,n = 10,len(s) if n&lt;=L: return [] #a的值不能改小，如果把a改成2，\"CA\"和\"AG\"相等，a的值由字典d决定 a = 4 aL = a ** L d = &#123;\"A\":0,\"C\":1,\"G\":2,\"T\":3&#125; nums = [d[c] for c in s] seen = set() output = set() h = 0 for i in range(n-L+1): if i == 0: for j in range(L): h = h * a + nums[j] else: h = h * a - nums[i-1]*aL + nums[i+L-1] if h in seen: output.add(s[i:i+L]) else: seen.add(h) return list(output) 解法三：滑动窗口+位运算A=00,C=01,G=10,T=11 总共会出现四个字母，因此每个字母可以用两位二进制位来表示。 每次用bitmask左移两位与当前数取或运算。 算法其他部分如方法二。 1234567891011121314151617181920212223242526272829class Solution: def findRepeatedDnaSequences(self, s: str) -&gt; List[str]: L, n = 10, len(s) if n &lt;= L: return [] to_int = &#123;'A': 0, 'C': 1, 'G': 2, 'T': 3&#125; nums = [to_int.get(s[i]) for i in range(n)] bitmask = 0 seen, output = set(), set() for start in range(n - L + 1): if start != 0: #左移两位用来放新的字母 bitmask &lt;&lt;= 2 bitmask |= nums[start + L - 1] #(3 &lt;&lt; 2 * L)表示将11左移20位，表示22位数字的高两位设置为1，其他为0， #加了‘~’表示取反，将高两位设置为1，余位设置位0 #再拿bitmask取并，表示将bitmask的高两位设置为0，其他位不变 bitmask &amp;= ~(3 &lt;&lt; 2 * L) else: for i in range(L): bitmask &lt;&lt;= 2 bitmask |= nums[i] print(bitmask) print(bin(bitmask)) if bitmask in seen: output.add(s[start:start + L]) seen.add(bitmask) return list(output)","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"LeetCode150、逆波兰表达式求值","slug":"LeetCode150","date":"2020-07-30T14:13:46.790Z","updated":"2020-09-05T12:35:08.713Z","comments":true,"path":"2020/07/30/LeetCode150/","link":"","permalink":"http://yoursite.com/2020/07/30/LeetCode150/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/ 解法：栈、python除法逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。 有坑：python除法向下取整。 主要是负数除法操作，-45//7算出来的结果是-7。 原因是负数除法第一个数到第二个数之间的距离是多少。 -45到７的距离为52，52//7=7，其结果在加上符号为-7。 12345678910111213141516171819202122232425class Solution: def evalRPN(self, tokens: List[str]) -&gt; int: if not tokens: return 0 stack = [] tokensLen = len(tokens) for i in range(tokensLen): if tokens[i] != \"+\" and tokens[i] != \"-\" and tokens[i] != \"*\" and tokens[i] != \"/\": stack.append(int(tokens[i])) else: num2 = stack.pop() num1 = stack.pop() if tokens[i] == \"+\": stack.append(num1+num2) elif tokens[i] == \"-\": stack.append(num1-num2) elif tokens[i] == \"*\": stack.append(num1*num2) else: #判断num1和num2是不是异号，用了异或操作符 if (num1&lt;0) ^ (num2&lt;0): stack.append((abs(num1)//abs(num2))*-1) else: stack.append(abs(num1)//abs(num2)) return stack[0]","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"逆波兰","slug":"逆波兰","permalink":"http://yoursite.com/tags/%E9%80%86%E6%B3%A2%E5%85%B0/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/%E6%A0%88/"}]},{"title":"LeetCode329、矩阵中的最长递增路径","slug":"LeetCode329","date":"2020-07-26T03:44:32.149Z","updated":"2020-09-05T12:34:29.882Z","comments":true,"path":"2020/07/26/LeetCode329/","link":"","permalink":"http://yoursite.com/2020/07/26/LeetCode329/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/ 解法：动态规划定义f(i,j)为以matrix[i][j]为起点的最长递增路径长度。 状态转移方程为：f(x,y) = max(f(i,j))+1 且i,j为x,y上下左右四个方向上的位置。num[x][y]&lt;num[i][j]是为了保证递增序列 1234567891011121314151617181920212223242526272829class Solution: def longestIncreasingPath(self, matrix: List[List[int]]) -&gt; int: if not matrix: return 0 m = len(matrix) n = len(matrix[0]) #用来保存过程中的结果，就是每个位置为起点的最长递增路径 arr = [[0]*n for _ in range(m)] #计算以x,y位置为起点的最长递增路径，最短的是x,y位置上的值比周围所有值都大，法形成递增序列，因此f(x,y)=1 def startLength(x,y): if arr[x][y] != 0:#表示计算过这个值 return arr[x][y] flag = False#用flag标记是否比周围值都大 for i,j in [(x-1,y),(x+1,y),(x,y-1),(x,y+1)]: if 0&lt;=i&lt;m and 0&lt;=j&lt;n and matrix[i][j]&gt;matrix[x][y]: flag = True if arr[i][j] != 0: arr[x][y] = max(arr[i][j]+1,arr[x][y]) else: arr[i][j] = startLength(i,j) arr[x][y] = max(arr[i][j]+1,arr[x][y]) if not flag:#比周围值都大设置为1 arr[x][y] = 1 return arr[x][y] res = 0 for x in range(m): for y in range(n): res = max(startLength(x,y),res) return res","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode410、分割数组求最小的最大值","slug":"LeetCode410","date":"2020-07-25T09:17:59.765Z","updated":"2020-09-05T12:34:03.571Z","comments":true,"path":"2020/07/25/LeetCode410/","link":"","permalink":"http://yoursite.com/2020/07/25/LeetCode410/","excerpt":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。","text":"想把自己刷题过程中一些，使用经典方法、思想的题记录下来。 题目地址： https://leetcode-cn.com/problems/split-array-largest-sum/ 解法一：动态规划定义f(i,j)为前i个数分成j组，所有分组方式中的最小的最大值。 可以从这i个数的尾部拿走一些值，组成尾数组tail，假设拿走k个值。 max(f(i-k,j-1),sum(tail))为当前分法的最大值，表示前i-k个数分为j-1组，后面的k个数成为一组。 分组的极限情况是每个数单独成为一组，也就是说i-k个数需要大于等于分组个数j-1，所以k&lt;=i-j+1。 采用自底向上的动态规划： 123456789101112131415161718192021class Solution: def splitArray(self, nums: List[int], m: int) -&gt; int: length = len(nums) #保存以各个数为结尾的和 arraySum = [0,nums[0]] for i in range(1,length): arraySum.append(arraySum[i]+nums[i]) #自底向上保存运行结果，需要求的是最小值，预先填入极大的值，要求result[length][m] result = [[10**18] * (m+1) for _ in range(length+1)] result[0][0] = 0 #前i个数分为j组的最小的最大值 for i in range(1,length+1): for j in range(1,m+1): if i&gt;=j: for k in range(1,i-j+2): result[i][j] = min(result[i][j],max(result[i-k][j-1],arraySum[i]-arraySum[i-k])) # print(result) return result[length][m] 解法二：二分查找+贪心我们要求取的值的范围在max(nums)到sum(nums)之间。因此可以用二分查找方法在max(nums)到sum(nums)之间遍历。找到要求的值。 贪心地模拟分割的过程，从前到后遍历数组，用sum 表示当前分割子数组的和，cnt 表示已经分割出的子数组的数量（包括当前子数组），那么每当sum 加上当前值超过了 x，我们就把当前取的值作为新的一段分割子数组的开头，并将 cnt 加 1。遍历结束后验证是否 cnt 不超过 m。 1234567891011121314151617181920212223class Solution: def splitArray(self, nums: List[int], m: int) -&gt; int: def check(x: int) -&gt; bool: total, cnt = 0, 1 for num in nums: if total + num &gt; x: cnt += 1 total = num else: total += num return cnt &lt;= m left = max(nums) right = sum(nums) while left &lt; right: mid = (left + right) // 2 if check(mid): right = mid else: left = mid + 1 return left","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"}]},{"title":"近期面试经验总结","slug":"近期面试经验总结","date":"2020-07-19T02:22:17.131Z","updated":"2020-09-05T12:37:38.894Z","comments":true,"path":"2020/07/19/近期面试经验总结/","link":"","permalink":"http://yoursite.com/2020/07/19/%E8%BF%91%E6%9C%9F%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/","excerpt":"近期面试了几个后端岗位，记录一下面试得出的经验。","text":"近期面试了几个后端岗位，记录一下面试得出的经验。 一、面试中的问题1.问简历上的项目大体来说就是会照着简历上写的项目来进行提问。首先，就是项目的总体框架，涉及到的技术栈。会对涉及到的知识进行提问。 其次，在项目中的具体工作，就是你负责了哪一部分。项目中遇到的困难，以及如何解决的。 最后，面试官问这些一个是测试你的技术掌握的深度，再一个就是看看你对技术的热情程度。所以需要在这个过程中体现出来自己对技术的热枕。 2.操作系统相关 进程管理 内存管理 死锁相关 3.计算机网络相关 http https http2.0 osi和tcp/ip网络模型 Tcp三次握手，四次挥手。这里不仅要知道怎么握手，还要知道为什么是三次和四次 cookie和session 从输入网址到显示页面，发生了什么 4.mysql相关 事务 定义及四个特征 隔离级别 innodb和myisam存储引擎 脏读，不可重复度和幻读 索引 索引的类型 匹配原则 底层数据结构：B+树 5.java5.1 java集合 hashmap arrayList 5.2 JVM 内存机构 垃圾回收机制 5.3 多线程 hashmap、hashtable、CurrentHashMap 锁 二、面试经验1.算法方面首先，要弄清楚面试官的需求。以及一些题目的要求。所以第一步是一定不要马上写代码！！！拿到题目要问清楚面试官的具体要求，然后把自己的具体思路讲述给面试官。思路得到面试官肯定后，再写代码。 其次，在写代码的过程中，一定要注意程序的鲁棒性。特别要考虑一些空值和边界值的情况 最后，面试官出的题目可能是连环题，在你写完代码之后，会问你写的程序的时间复杂度和空间复杂度。然后再问你优化方案。 2.项目经历方面首先一个明确你在项目中的工作，然后是技术难点和解决方案，也有可能是技术亮点。 这类问题回答过程中一定要体现自己对于技术的热情。 3.基础知识方面第一种就是单纯问你的基础知识，这方面理解的基础上记忆就好了。 第二种就比较复杂。面试官会结合具体的实际业务场景来对基础知识进行提问。这一块要求对知识的掌握程度更加深刻。","categories":[{"name":"面经","slug":"面经","permalink":"http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"字节跳动懂车帝后端面经","slug":"字节跳动懂车帝后端面经","date":"2020-07-17T12:45:07.499Z","updated":"2020-09-05T12:36:52.880Z","comments":true,"path":"2020/07/17/字节跳动懂车帝后端面经/","link":"","permalink":"http://yoursite.com/2020/07/17/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E6%87%82%E8%BD%A6%E5%B8%9D%E5%90%8E%E7%AB%AF%E9%9D%A2%E7%BB%8F/","excerpt":"找了学长内推了字节跳动懂车帝的后端岗位，这也是作者本人的第一次面试，有纪念意义，所以记录一下过程。","text":"找了学长内推了字节跳动懂车帝的后端岗位，这也是作者本人的第一次面试，有纪念意义，所以记录一下过程。 懂车帝后端主要用Go和python语言，因此相对来说就会少问一些java方面的知识。 面试的平台是在牛客网上，上来先做了一个简短的自我介绍，然后就直接开始问问题了。 问题1、从长度未知的链表中随机取出一个数。首先，需要说明这是一个经典的问题，需要用蓄水池抽样算法。但是本人当时并不知道这个算法。因此想出了两个方案，但是面试官都说不对，因此最后在面试官的提示下需要回去看看蓄水池算法。 错误方法1：先获取链表的长度，然后取链表长度的随机数，再取相应随机数位置的数。 面试官说不能获取链表的长度。 错误方法2：先生成一个随机数，然后取随机数位置上的链表上的数。会出现两种情况，一种是数到相应的位置上有数，直接取。第二种情况，向后遍历链表直到链表尾，发现随机数大于链表长度，这时候用随机数对链表长度取余数。取余数位置上的数。 面试官说还是需要获取到链表的长度。WTF？向后遍历到链表的尾部的同时就能够记录到链表的长度的啊。 正确答案：蓄水池取水算法 前提：给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。（这里面试官没有说出来只能够遍历一次链表）。本题面试官提出的是取一个数据，因此把m设置为1即可。 算法思路大致如下： 如果接收的数据量小于m，则依次放入蓄水池。 当遍历到第i个数据时，i &gt;= m，在[0, i]范围内取以随机数d，若d的落在[0, m-1]范围内，则用这第i个数据替换蓄水池中的第d个数据。 重复步骤2。 算法随机性的证明： 第i个数据最后能够留在蓄水池中的概率=第i个数据进入过蓄水池的概率*第i个数据不被替换的概率（第i+1到第N次处理数据都不会被替换）。 当i&lt;=m时，数据直接放进蓄水池，所以第i个数据进入过蓄水池的概率=1。 当i&gt;m时，在[1,i]内选取随机数d，如果d&lt;=m，则使用第i个数据替换蓄水池中第d个数据，因此第i个数据进入蓄水池的概率=m/i。 当i&lt;=m时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为m/(m+1)，会替换掉第i个数据的概率为1/m，则第m+1次处理替换掉第i个数据的概率为(m/(m+1))*(1/m)=1/(m+1)，不被替换的概率为1-1/(m+1)=m/(m+1)。依次，第m+2次处理不替换掉第i个数据概率为(m+1)/(m+2)…第N次处理不替换掉第i个数据的概率为(N-1)/N。所以，之后第i个数据不被替换的概率=m/(m+1)*(m+1)/(m+2)*...*(N-1)/N=m/N。（这里如果m==1，表示只取一个数据，因此概率为1/N） 当i&gt;m时，程序从接收到第i+1个数据时开始有可能替换第i个数据。则参考上述第3点，之后第i个数据不被替换的概率=i/N。 结合第1点和第3点可知，当i&lt;=m时，第i个接收到的数据最后留在蓄水池中的概率=1*m/N=m/N。结合第2点和第4点可知，当i&gt;m时，第i个接收到的数据留在蓄水池中的概率=m/i*i/N=m/N。综上可知，每个数据最后被选中留在蓄水池中的概率为m/N。 这个算法建立在统计学基础上，很巧妙地获得了&quot;m/N&quot;这个概率。 问题2、写一个斐波那契数列。给n求n位置上的值0、1、1、2、3、5…… 123456def fib(n): if n == 0: return 0 if n == 1: return 1 return fib(n-1)+fib(n-2) 问题3、斐波那契数列递归算法的时间空间复杂度，以及如何优化时间复杂度O（n） 空间复杂度O（n） 优化采用自底向下的动态规划算法。 12345def fib(n): res = [0,1] for i in range(2,n+1): res.append(res[-1]+res[-2]) return res[n] 这种算法需要空间空间复杂度为O(n),可以再优化为常数级别。 12345678def fib(n): num1 = 0 num2 = 1 if n == 0: return num1 for i in range(2,n+1): num1,num2 = num2,num1+num2 return num2 说起来惭愧，这是《剑指offer》上的原题，面试之前作者并没有读过，当时又非常紧张，没有写出来这道题。面完试感觉这道题是easy的。 问题4.操作系统什么时候会从用户态进入到内核态内核态主要涉及到一些特权指令的操作。发生系统调用时会从用户态转移到内核态。 系统调用： 设备管理 文件管理 进程控制 进程通信 内存管理 问题5.Tcp拥塞控制 慢开始 拥塞避免 快重传 快恢复 慢开始：指数增长就是将拥塞窗口cwnd设置为1，没经过一个RTT，cwnd加倍，指数增长。知道到达满开始门限阈值采用拥塞避免算法。 拥塞避免：线性zeng’zhang每经过一个RTT就增加一个MSS大小。知道出现第一次超时（网络拥塞），就将慢开始门限设置为此时拥塞窗口值的一半。然后把cwnd重置为1。执行慢开始算法。 快重传：当发送方接收到3个冗余ACK时，就认为确认的报文后面的报文段丢失了。并立即对缺失的报文段重传。 快恢复：就是发生冗余ACK时间时候，将慢开始门限设置为当前的一半，然后将cwnd设置慢开始门限值，开始拥塞避免算法。 问题6.进程通信方式 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 问题7.Tcp连接三次握手，为什么不是两次 654b2aab47dbab75a9813b891790d60 第一次握手：客户机向服务器发送连接请求报文。 第二次握手：服务器的TCP收到连接请求报文之后，同意链接，向客户机发回确认，为TCP连接分配TCP缓存和变量。 第三次握手：客户机收到确认报文，向服务器发送确认报文为连接分配缓存和变量。 为什么不是两次？ ​ 防止客户端失效的连接请求报文段突然又传到服务器 例如以下情况如果使用两次握手： 如果客户端向服务器发送第一次连接请求在网络节点上滞留了，没有收到服务器的确认，于是又重新发送了一次连接请求 服务器收到客户端的第二次请求发送确认，则连接建立完成 服务器客户端进行数据传输，传输完成断开连接。 此时，在网络上滞留的客户端第一次连接请求到达服务器，服务器发送确认连接但是客户端实际上并没有发送请求，因此不会理睬服务器发送的请求。但是服务器认为连接已完成，并等待客户端进行数据传输。这样会造成资源的浪费 如果采用三次握手的话： 滞留在网络上的客户端第一次请求到达服务器之后，服务器发送确认，但实际上服务器并没有发送请求，因此不会理睬服务器的确认，故不会发送确认，服务器等不到客户端的确认则连接建立失败。这样就防止了客户端失效的连接请求报文段突然又传到服务器 总结这是作者本人的第一次面试，面试的时候很紧张。面试官出了编程题马上就上手去写，没有思考的过程，也没有去问具体的一些要求。导致越写越慌，到最后连斐波那契数列这样的基础题，也没有写出来。基础知识也很不牢靠，一些简单的问题，也没有答上来。 在面试后在网上找了一些《剑指offer》的资料，发现前几章很有帮助，其中比较重要的一点就是，拿到面试题先思考，不理解需求的问，想清楚了之后再具体的写代码。 一些面试题答案的参考文献： https://www.jianshu.com/p/7a9ea6ece2af https://blog.csdn.net/zhaohong_bo/article/details/89552188 https://blog.csdn.net/qq_41727218/article/details/87881235","categories":[{"name":"面经","slug":"面经","permalink":"http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"字节跳动","slug":"字节跳动","permalink":"http://yoursite.com/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"python集合的一些基本操作","slug":"python集合的一些基本操作","date":"2020-07-12T13:03:11.494Z","updated":"2020-09-05T12:38:24.191Z","comments":true,"path":"2020/07/12/python集合的一些基本操作/","link":"","permalink":"http://yoursite.com/2020/07/12/python%E9%9B%86%E5%90%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"刷题过程中有时需要用到集合相关的数据结构，主要是list、set和dict。记录一下如何在刷题过程中应用这些结构。","text":"刷题过程中有时需要用到集合相关的数据结构，主要是list、set和dict。记录一下如何在刷题过程中应用这些结构。 一、list1、列表的创建12345nums = []#快速创建队列并赋值nums = [0 for _ in range(n)]#快速创建二维数组，并赋值nums = [[0 for _ in range(n)] for _ in range(m)] 2、列表的压入12nums.append(x)nums.insert(index,x)#在index插入x 3、列表的删除12x = nums.pop(1)#删除index为1的元素list.remove(2)#删除元素2的第一个匹配项 4、列表排序12nums.sort()nums.sort(key=None,reverse=False) 5、反转列表1nums.reverse() 6、复制列表1nums.copy() 7、列表中某个元素出现的个数1nums.count(x)#x出现的次数 8、某个值的第一个匹配项的index1nums.index(x) 二、set1、集合的创建1nums = &#123;&#125; 2、集合的压入12345nums.add(x)#高级方法nums.update(x)#x可以是列表、元组、字典，且x可以又多个，用逗号隔开nums.update([1,4],[5,6])#&#123;1, 3, 4, 5, 6&#125; 3、集合的删除12nums.remove(x)#如果元素不存在会发生错误nums.discard(x)#如果元素不存在不会发生错误 三、dict1、字典的创建1nums = &#123;&#125; 2、字典的压入1nums[x] = y 3、字典的删除1del nums[x] 4、字典的遍历4.1、遍历键1234for key in nums: print(nums[key])#或者for key in nums.keys(): 4.2、遍历值12for value in nums.values(): print(value) 4.3、遍历键和值1for k,v in nums.items():","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"python刷题过程中的栈、队列和堆的实现","slug":"python刷题的栈队列和堆的实现","date":"2020-07-12T12:49:55.263Z","updated":"2020-09-05T12:38:38.999Z","comments":true,"path":"2020/07/12/python刷题的栈队列和堆的实现/","link":"","permalink":"http://yoursite.com/2020/07/12/python%E5%88%B7%E9%A2%98%E7%9A%84%E6%A0%88%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"刷题过程中有时需要用到栈、队列和堆的数据结构，记录一下如何在刷题过程中快速应用","text":"刷题过程中有时需要用到栈、队列和堆的数据结构，记录一下如何在刷题过程中快速应用 一、栈1、栈的创建1stack = [] 2、栈的压入1stack.append(x) 3、栈的弹出1x = stack.pop() 二、队列1、队列的创建12from collections import dequequeue = deque() 2、队列的压入1queue.append(x) 3、队列的弹出1x = stack.popleft() 三、堆（最小堆）注意：heapq默认是创建的最小堆，如果需要最大堆，就将-x存入堆中。 1、栈的创建12345import heapqheap = []#新建#或者将列表变成小顶堆nums = [......]heapq.heapify(nums) 2、堆的压入1heapq.heappush(heap,x) 3、堆的弹出1heapq.heappop(heaq) 4、寻找序列中最大或最小的N个元素123lista = [64, 92, 93, 83, 85, 50, 10, 49, 28, 60]print(heapq.nlargest(3, lista)) # [93, 92, 85]print(heapq.nsmallest(3, lista)) # [10, 28, 49]","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"win10下运行hadoop的wordcount程序报错","slug":"WordCount程序报错","date":"2020-06-27T12:15:08.039Z","updated":"2020-09-05T12:38:18.071Z","comments":true,"path":"2020/06/27/WordCount程序报错/","link":"","permalink":"http://yoursite.com/2020/06/27/WordCount%E7%A8%8B%E5%BA%8F%E6%8A%A5%E9%94%99/","excerpt":"学习hadoop的过程中遇到了一个bug，记录一下过程","text":"学习hadoop的过程中遇到了一个bug，记录一下过程 Exception in thread“main”java.lang.UnsatisfiedLinkError: org.apache.hadoop.io.nativeio.NativeIO$Windows.access0(Ljava/lang/String;I)Z第一步、检查系统环境变量1、检查HADOOP_HOME image-20200627202154495 2、检查PATH image-20200627202320374 第二步、检查hadoop/bin文件夹主要检查是否有winutils.exe和hadoop.dll两个文件。 如果没有的话请从网上下载，要下载对应版本的文件。 第三步、检查C:\\Windows\\System32文件夹检查是否有hadoop.dll文件，如果没有的话，从hadoop/bin文件夹下复制过去。 文章来源：https://sparkbyexamples.com/spark/spark-hadoop-exception-in-thread-main-java-lang-unsatisfiedlinkerror-org-apache-hadoop-io-nativeio-nativeiowindows-access0ljava-lang-stringiz/","categories":[{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/categories/hadoop/"}],"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/tags/hadoop/"},{"name":"wordcount","slug":"wordcount","permalink":"http://yoursite.com/tags/wordcount/"}]},{"title":"CentOS7设置防火墙","slug":"CentOS7防火墙设置","date":"2020-06-26T04:22:20.489Z","updated":"2020-09-05T12:37:32.670Z","comments":true,"path":"2020/06/26/CentOS7防火墙设置/","link":"","permalink":"http://yoursite.com/2020/06/26/CentOS7%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE/","excerpt":"CentOS7设置防火墙，记录一下过程","text":"CentOS7设置防火墙，记录一下过程 1、防火墙设置 启动防火墙：systemctl start firewalld.service 关闭防火墙：systemctl stop firewalld.service 重启防火墙：systemctl restart firewalld.service 显示防火墙状态：systemctl status firewalld.service 开机自动开启防火墙：systemctl enable firewalld.service 开机禁用防火墙：systemctl disable firewalld.service 查看防火墙是否开机启动：systemctl is-enabled firewalld.service 查看已启动的服务列表：systemctl list-unit-files|grep enabled 查看启动失败的服务列表：systemctl --failed 2、防火墙配置 查看版本： firewall-cmd --version 查看帮助： firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口： firewall-cmd --zone=public --list-ports 更新防火墙规则：firewall-cmd --reload 查看区域信息: firewall-cmd --get-active-zones 查看指定接口所属区域：firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态： firewall-cmd --panic-off 查看是否拒绝： firewall-cmd --query-panic 添加开放端口：firewall-cmd --zone=public --add-port=80/tcp --permanent （–permanent永久生效，没有此参数重启后失效） 删除开放端口：firewall-cmd --zone=public --remove-port=80/tcp --permanent 查看开放端口：firewall-cmd --zone=public --query-port=80/tcp","categories":[{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/categories/CentOS/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/tags/CentOS/"}]},{"title":"scrapy爬虫","slug":"scrapy爬虫","date":"2020-06-15T16:01:06.077Z","updated":"2020-09-05T12:38:11.187Z","comments":true,"path":"2020/06/16/scrapy爬虫/","link":"","permalink":"http://yoursite.com/2020/06/16/scrapy%E7%88%AC%E8%99%AB/","excerpt":"学习了一下scrapy爬虫，记录一下过程。","text":"学习了一下scrapy爬虫，记录一下过程。 一、新建工程1. 创建项目powershell下： 1scrapy startproject 工程名称 2. 创建爬虫程序12cd 工程名称scrapy genspider 程序名称 爬取的网站地址 注意：==网站地址前面不要有http://之类的== 3. 启动spider1scrapy crawel 程序名称 二、文件说明 scrapy.cfg：项目的配置信息，主要为Scrapy命令行工具提供一个基础的配置信息。（真正爬虫相关的配置信息在settings.py文件中） items.py：设置数据存储模板，用于结构化数据，如：Django的Model pipelines：数据处理行为，如：一般结构化的数据持久化 settings.py：配置文件，如：递归的层数、并发数，延迟下载等 spiders：爬虫目录，如：创建文件，编写爬虫规则 以上命名都是固定的 1. items.py：12345import scrapyclass ThirdItem(scrapy.Item): name = scrapy.Field() age = scrapy.Field() 2. example.pyexample.py是scrapy genspider命令中spider名称 12345678910111213141516171819202122232425262728293031# -*- coding: utf-8 -*-import scrapyfrom urllib import parsefrom scrapy.http import Requestfrom ..items import Item#导入自定义的item结构化数据类class ExampleSpider(scrapy.Spider): name = 'example' allowed_domains = ['example.com'] start_urls = ['http://example.com']#要爬取的网页 def parse(self, response): print(response.body)#打印获取到的网页源码 #获取页面数据的两种方式 #url = response.css(' ').extract() url = response.xpath(' ').extract() for next_url in url: yield Request(url=parse.urljoin(response.url, next_url), callback=self.parse_detail)#parse_detail为自定义函数 def parse_detail(self, response): print(\"================进入parse_detail=================\") print(response.body)#打印url的源码 items = Item() items['name'] = response.xpath(' ').extract_first(\"\") items['name'] = items['name'].replace('\\n', '').replace(' ', '') items['age'] = response.xpath(' ').extract_first(\"\") items['age'] = items['age'].replace('\\n', '').replace(' ', '') yield items 4. main.py在pycharm里，可以将指令写入main.py中，简化操作。 1234from scrapy import cmdline#cmdline.execute(\"scrapy\",\"crawl\",\"example\")cmdline.execute(\"scrapy crawl example\".split()) 如果没有出现运行标志，表示需要配置： 配置 添加新配置 配置信息 ==工作目录需要选择py文件的父文件夹== 三、延迟获取对于浏览器看到的和实际打印的response.body不同的解决方法有两种，两种都可以进行尝试。 1. DOWNLOAD_DELAY在setting.py中找到DOWNLOAD_DELAY取消注释设置值。 1DOWNLOAD_DELAY = 5 #数值越大，延迟越大 2. middleware2.1 安装selenium1pip install selenium 2.2 安装chromedriver注意：==chromedriver的版本一定要与Chrome的版本一致，不然就不起作用。== 查看chrome版本方法：在浏览器地址栏输入chrome://version/ 两个下载地址： http://chromedriver.storage.googleapis.com/index.html https://npm.taobao.org/mirrors/chromedriver/ 解压压缩包，找到chromedriver.exe复制到chrome的安装目录（其实也可以随便放一个文件夹）。复制chromedriver.exe文件的路径并加入到电脑的环境变量中去（不添加也行，得记住路径）。具体的： image-20200407175944138 进入环境变量编辑界面，添加到用户变量即可，双击PATH，将你的文件位置（C:\\Program Files (x86)\\Google\\Chrome\\Application）添加到后面。 image-20200407180622270 打开cmd，输入chromedriver监测是否安装成功。 image-20200407180356103 2.3 配置 将settings.py中的DOWNLOADER_MIDDLEWARES解除注释。 在middlewares.py导入将需要的包并且设置变量。 123456789import timefrom scrapy.http import HtmlResponsefrom selenium import webdriverfrom selenium.common.exceptions import TimeoutExceptionfrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument('--headless')driver = webdriver.Chrome(\"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe\",chrome_options=chrome_options) 在middlewares.py找到相应的middleware的类中的process_request函数，函数中添加以下代码，代码块如图。其中起关键作用的是time.sleep(10)，意思是延迟多长时间。延迟后再返回current.url和body。本例中类名为MyCrowlersDownloaderMiddleware，具体类名会根据项目名变化。 1234567try: driver.get(request.url)except TimeoutException: print('超时，丢弃本页', request.url) driver.execute_script('window.stop()')time.sleep(10)return HtmlResponse(url=driver.current_url, body=driver.page_source, encoding=\"utf-8\",request=request) 2.4 滚动加载配置（这部分好像有问题） 在middlewares.py新导入一个包。 1from selenium.common.exceptions import TimeoutException 在process_request函数中添加以下代码，代码块如图。 12345678try: spider.browser.get(request.url) spider.browser.execute_script('window.scrollTo(0, document.body.scrollHeight)')except TimeoutException as e: print('超时') spider.browser.execute_script('window.stop()')time.sleep(2)return HtmlResponse(url=spider.browser.current_url, body=spider.browser.page_source, encoding=\"utf-8\",request=request) 四、保存数据共使用三种保存方法，一种是保存为json文件，一种是直接保存到es中。 1. 保存至json 在piplines.py中添加如下代码 1234567891011121314151617181920212223class ScrapyCodePipeline(object): def process_item(self, item, spider): # print('pipeline got item:',item) return itemfrom scrapy.exporters import JsonItemExporterclass JsonExporterPipleline(object): # 调用scrapy提供的json export导出json文件 def __init__(self): self.file = open('export.json', 'wb') self.exporter = JsonItemExporter(self.file, encoding=\"utf-8\", ensure_ascii=False) self.exporter.start_exporting() def close_spider(self, spider): self.exporter.finish_exporting() self.file.close() def process_item(self, item, spider): self.exporter.export_item(item) return item 在settings.py中找到ITEM_PIPELINES，改成如下。 123456ITEM_PIPELINES = &#123;# item处理方式 # 'scrapy_code.pipelines.ScrapyCodePipeline': 300, 'scrapy_code.pipelines.JsonExporterPipleline': 300, # 'scrapy_code.pipelines.MysqlTwistedPipline': 300, # 'scrapy_code.pipelines.ElasticsearchPipeline': 1&#125; 2. 保存至es中 在piplines.py的同级文件夹下建立Python Package，取名为models，在models下建立es_types.py。目录结构如下： models: _init_.py es_types.py piplines.py 在es_types.py中写入如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# -*- coding: utf-8 -*-# elasticsearch_dsl：https://elasticsearch-dsl.readthedocs.io/en/latest/from elasticsearch_dsl import DocType, Date, Completion, Keyword, Text, Integerfrom elasticsearch_dsl.analysis import CustomAnalyzer#需要在es中安装ik分词器ik_analyzer = CustomAnalyzer(\"ik_max_word\", filter=[\"lowercase\"])from elasticsearch_dsl.connections import connectionses=connections.create_connection(host=\"127.0.0.1\")class jobType(DocType): # 设置index名称和document名称 class Index: name = \"51job\" doc_type = \"_doc\" # settings = &#123; # \"number_of_shards\": 2, # &#125; # TODO:fileds定义 url = Keyword() # 不分词，默认保留256个字符 job_name = Text( analyzer=\"ik_max_word\") # “中华人民共和国国歌”拆分为“中华人民共和国,中华人民,中华,华人,人民共和国,人民,人,民,共和国,共和,和,国国,国歌”，会穷尽各种可能的组合； salary = Text(analyzer=\"ik_smart\") # 将“中华人民共和国国歌”拆分为“中华人民共和国,国歌”将“中华人民共和国国歌”拆分为“中华人民共和国,国歌” company = Text(analyzer=\"ik_max_word\") job_position = Text(analyzer=\"ik_max_word\") experience = Text(analyzer=\"ik_max_word\") education = Text(analyzer=\"ik_max_word\") number_of_people = Integer() published_time = Date() position_detail = Text(analyzer=\"ik_smart\") position_type = Text(analyzer=\"ik_max_word\") location = Text(analyzer=\"ik_max_word\") company_detail = Text(analyzer=\"ik_max_word\") suggest = Completion(analyzer=ik_analyzer) # 搜索建议 def __init__(self,item): super(jobType, self).__init__()#调一下父类的init，避免init重写导致一些init操作没执行 self.assignment(item) # TODO:将item转换为es的数据 def assignment(self, item): # TODO：给没爬到的字段赋默认值：空串 keys = ['url', 'job_name', 'salary', 'company', 'job_position', 'experience', 'education', 'number_of_people', 'published_time', 'position_detail', 'position_type', 'location', 'company_detail'] for key in keys: try: item[key] except: item[key] = '' # TODO：将字段值转换为es的数据 # 虽然只是将原来的item值赋给了成员变量，但这个过程中会执行数据格式转换操作，比如url本来在item是python的字符串类型，转换后变为es的keyword类型 self.url = item['url'] self.job_name = item['job_name'] self.salary = item['salary'] self.company = item['company'] self.job_position = item['job_position'] self.experience = item['experience'] self.education = item['education'] self.number_of_people = item['number_of_people'] self.published_time = item['published_time'] self.position_detail = item['position_detail'] self.position_type = item['position_type'] self.location = item['location'] self.company_detail = item['company_detail'] # # 或者简化代码为 # for key in keys: # vars(self)[key]=item[key] # TODO：生成搜索建议词 self.suggest = self.gen_suggests(((self.job_name, 10), (self.company, 3), (self.position_type, 7))) def gen_suggests(self, info_tuple): # 根据字符串生成搜索建议数组 used_words = set() # set为去重功能 suggests = [] for text, weight in info_tuple: if text: # 字符串不为空时，调用elasticsearch的analyze接口分析字符串（分词、大小写转换） words = es.indices.analyze(body=&#123;'text': text, 'analyzer': \"ik_max_word\"&#125;) # anylyzed_words = set([r[\"token\"] for r in words[\"tokens\"] if len(r[\"token\"]) &gt; 1]) analyzed_words = [] for r in words[\"tokens\"]: if len(r[\"tokens\"]) &gt; 1: analyzed_words.append(r[\"tokens\"]) anylyzed_words = set(analyzed_words) new_words = anylyzed_words - used_words else: new_words = set() if new_words: suggests.append(&#123;'input': list(new_words), 'weight': weight&#125;) return suggests 在piplines.py中添加如下代码 1234567891011121314from .models.es_types import jobTypeclass ElasticsearchPipeline(object): def process_item(self, item, spider): job = jobType(item)# 将item转换为es所需格式 # 将数据传入es # jobType继承自DocType，所以DocType有的函数，它都有。 # save就是DocType定义的将类中的各成员变量打包成数据插入操作，进行数据插入的函数 job.save() #仍返回item，使得运行窗口能看到爬到的数据 return item 在settings.py中找到ITEM_PIPELINES，改成如下。 123456ITEM_PIPELINES = &#123;# item处理方式 # 'scrapy_code.pipelines.ScrapyCodePipeline': 300, # 'scrapy_code.pipelines.JsonExporterPipleline': 300, # 'scrapy_code.pipelines.MysqlTwistedPipline': 300, 'scrapy_code.pipelines.ElasticsearchPipeline': 1&#125;","categories":[{"name":"scrapy","slug":"scrapy","permalink":"http://yoursite.com/categories/scrapy/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"scrapy","slug":"scrapy","permalink":"http://yoursite.com/tags/scrapy/"}]},{"title":"jar包部署","slug":"jar包部署","date":"2020-06-15T15:56:51.079Z","updated":"2020-09-05T12:38:43.468Z","comments":true,"path":"2020/06/15/jar包部署/","link":"","permalink":"http://yoursite.com/2020/06/15/jar%E5%8C%85%E9%83%A8%E7%BD%B2/","excerpt":"将项目部署到CentOS上，简单记忆一下部署的方法。","text":"将项目部署到CentOS上，简单记忆一下部署的方法。 前台运行项目（不能关掉shell）1Java -jar xxxxx.jar 后台运行项目（可以关掉shell）1nohup java -jar xxxxx.jar &amp; 后台运行项目不输出.out文件1nohup java -jar xxxxx.jar &gt;/dev/null 2&gt;&amp;1 &amp; 后台运行项目只输出错误信息到文件1nohup java -jar xxxxx.jar &gt;/dev/null 2&gt;error &amp; 停止项目12netstat -anp | grep 8080kill sid xxxx","categories":[{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/categories/CentOS/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"CentOS7设置网络","slug":"CentOS7设置网络","date":"2020-05-20T12:50:09.968Z","updated":"2020-09-05T12:37:21.992Z","comments":true,"path":"2020/05/20/CentOS7设置网络/","link":"","permalink":"http://yoursite.com/2020/05/20/CentOS7%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C/","excerpt":"CentOS7设置固定IP，记录一下过程","text":"CentOS7设置固定IP，记录一下过程 本文设置的网络是NAT模式+固定IP。 一、VM设置本文使用的虚拟机时VMware Workstation Pro。 1、设置虚拟机的连接方式选择自己要设置的虚拟机，选择虚拟机(M)-&gt;设置，选择网咯适配器，选择为NAT模式。 image-20200520194124851 2、配置虚拟机的NAT模式具体地址参数选择编辑(E)-&gt;虚拟机网络编辑器，点击更改设置。 image-20200818165231769 选择VMnet8-&gt;取消勾选使用本地DHCP-&gt;设置自己的子网ip（最好设置和自己的主机在同一个域内）-&gt;选择NAT设置。记住NAT设置中的三个地址。 image-20200818174649942 找到计算机控制面板-&gt;网络和Internet-&gt;网络和共享中心-&gt;左侧的更改适配器设置。 先择VMnet8右键属性-&gt;选择IPv4属性-&gt;设置自定ip地址。这里ip地址设置为子网内的ip就可，注意不要和想设置的虚拟机固定IP相同。 image-20200818175557387 二、CentOS7设置本文使用的虚拟机时VMware Workstation Pro。 1、查看网络名和ip首先查看自己需要配置的网络名称和目前的ip地址。 1ip addr image-20200520202702641 2、修改ip地址文件(需要root权限)查看文件夹下文件，找到和自己网络名相同的。 12cd /etc/sysconfig/network-scripts/ls image-20200520203141320 编辑： 1vim ifcfg-ens33 image-20200818180048862 BOOTPROTO：设置为静态ip ONBOOT：开机启动 DNS1：这里直接设置为114.114.114.114 IPADDR：想设置的虚拟机的固定IP地址 NETMASK：掩码 GATEWAY：网关地址 重启网络服务： 1systemctl restart network.service 验证： 123ip addr#查看自己的ip地址ping 主机地址#windows通过ipconfig获得ping www.baidu.com#查看自己是否能连接到网络 再从主机ping 虚拟机固定ip。 3、添加hosts1vim /etc/hosts 在文件中添加映射即可。例如我是要配置hadoop集群，分别有192.168.2.132、192.168.2.133、192.168.2.134三台机子。可以在hosts中添加如下配置： 123192.168.2.132 hadoop132192.168.2.133 hadoop133192.168.2.134 hadoop134 这时候就可以尝试ping各个主机了： 从本机ping虚拟机：ping 192.168.2.132 从虚拟机ping主机：ping 主机ip 从虚拟机ping虚拟机：ping hadoop133 4、修改hostname1hostnamectl set-hostname xxx 如本机是192.168.40.132，则 1hostnamectl set-hostname hadoop132 然后可以输入如下命令检查hostname： 1hostname","categories":[{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/categories/CentOS/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/tags/CentOS/"}]},{"title":"CentOS7安装JDK1.8","slug":"CentOS7安装Jdk1.8","date":"2020-05-17T06:31:20.727Z","updated":"2020-09-05T12:39:17.075Z","comments":true,"path":"2020/05/17/CentOS7安装Jdk1.8/","link":"","permalink":"http://yoursite.com/2020/05/17/CentOS7%E5%AE%89%E8%A3%85Jdk1.8/","excerpt":"为公司服务器安JDK，记录一下过程","text":"为公司服务器安JDK，记录一下过程 第一步、卸载系统自带的OpenJDK及相关的java文件1、查看系统自带OpenJDK版本1java -version 2、查找需要删除的相关文件1rpm -qa | grep java 命令说明： rpm：管理套件 -qa：使用询问模式，查询所有套件 grep：查找文件里符合条件的字符串 java：查找包含java字符串的文件 3、删除文件这里删除带OpenJDK字样的文件即可，例如： 1rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64 命令介绍： rpm：管理套件 -e：删除指定的套件 –nodeps：不验证套件档的相互关联性 4、检查是否删除成功1java -version 出现未找到命令...则表示删除成功。 第二步、下载JDK1.81、下载JDK下载地址：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 这里下载对应的tar.gz文件即可CentOS7对应下载： QQ截图20200517133840 注意：现在下载低于1.8版本的jdk需要登录，从网上找到了一个账号，亲测可用。 账号：2696671285@qq.com 密码：Oracle123 2、上传JDK至服务器注意：如果上一步是直接在CentOS7中下载的这一步可以跳过。笔者是在win10系统中下载的JDK压缩包。 简单说一下，连接你的服务器，通过sftp服务将压缩包上传至服务器。这里好用推荐一个软件：Bitvise SSH Client 登录服务器后，它会自动打开，shell窗口和Sftp窗口。 QQ截图20200517135255 直接上传你的压缩包即可。 第三步、安装JDK1、解压首先需要将压缩包移动到/usr/java文件夹下 1cp jdk-8u251-linux-x64.tar.gz /usr/java 随后到/usr/java下解压 12cd /usr/javatar -zxvf jdk-8u251-linux-x64.tar.gz 2、配置环境变量修改配置文件 1vim /etc/profile 进入文本编辑状态下，光标走到文件最后一行，键盘按下： 1i 进入插入状态： 在文本的最后一行粘贴如下： 注意：JAVA_HOME=/usr/java/jdk1.8.0_251就是你自己的目录 1234\\#java environmentexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_251export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;jre&#x2F;lib&#x2F;rt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;dt.jar:$&#123;JAVA_HOME&#125;&#x2F;lib&#x2F;tools.jarexport PATH&#x3D;$PATH:$&#123;JAVA_HOME&#125;&#x2F;bin image-20200517141720911 点击esc进入命令模式，输入：wq!保存修改信息 然后键入以下命令使配置文件生效： 1source /etc/profile 3、检查是否配置成功1java -version image-20200517142140209 至此JDK1.8就安装好了。","categories":[{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/categories/CentOS/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/tags/CentOS/"},{"name":"JDK","slug":"JDK","permalink":"http://yoursite.com/tags/JDK/"}]},{"title":"CentOS7安装MySQL5.7","slug":"CentOS7安装MySQL","date":"2020-05-16T12:20:45.876Z","updated":"2020-09-05T12:39:10.827Z","comments":true,"path":"2020/05/16/CentOS7安装MySQL/","link":"","permalink":"http://yoursite.com/2020/05/16/CentOS7%E5%AE%89%E8%A3%85MySQL/","excerpt":"为公司服务器安装MySQL，记录一下过程","text":"为公司服务器安装MySQL，记录一下过程 注意：在CentOS中默认是装有MariaDB的，但为了需要，还是要在系统中安装MySQL，而且安装完成之后可以直接覆盖掉MariaDB。 第一步： 下载并安装MySQL官方的Yum Repository1、下载安装文件1wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 使用上面的命令就直接下载了安装用的Yum Repository，大概25KB的样子，然后就可以直接yum安装了。 2、执行安装1yum -y install mysql57-community-release-el7-10.noarch.rpm 之后就开始安装MySQL服务器。 1yum -y install mysql-community-server 安装完成，会出现Complete!的提示。 第二步： MySQL数据库设置1、启动MySQL1systemctl start mysqld.service 查看MySQL运行状态，运行状态如图： 1systemctl status mysqld.service 2、查找临时密码通过如下命令可以在日志文件中找出密码： 1grep \"password\" /var/log/mysqld.log 注意：如果这里在日志文件中查找不到密码，很可能是之前安装过MySQL没有卸载干净。 处理方法： 删除原来安装过的mysql残留的数据（这一步非常重要，问题就出在这） 1rm -rf /var/lib/mysql 重启mysqld服务 1systemctl restart mysqld 这时候再去找临时密码就能找到了 1grep 'temporary password' /var/log/mysqld.log 3、进入数据库并修改密码1mysql -uroot -p 输入查找到的临时密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库： 1ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password'; 其中‘new password’替换成你要设置的密码，注意:密码设置必须要大小写字母数字和特殊符号（,/‘;:等）,不然不能配置成功 如果要修改为root这样的弱密码，需要进行以下配置： 查看密码策略 1show variables like '%password%'; 修改密码策略 1vi /etc/my.cnf 在文件中添加一下配置。 选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件 1234#添加validate_password_policy配置validate_password_policy=0#关闭密码策略validate_password = off 重启mysql服务使配置生效 1systemctl restart mysqld 然后就可以修改为弱密码了。 第三步： 开启MySQL远程访问1、开启MySQL的远程访问执行以下命令开启远程访问限制 注意： 1、下面命令开启的可访问数据库的IP： 192.168.0.1，如要开启所有的，用%代替IP 2、需要用自己的密码代替下面的password 1grant all privileges on *.* to 'root'@'192.168.0.1' identified by 'password' with grant option; 然后再输入下面两行命令 12flush privileges; exit; 2、为firewall添加开放端口添加mysql端口3306 1firewall-cmd --zone=public --add-port=3306/tcp --permanent 然后再重新载入 1firewall-cmd --reload","categories":[{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/categories/CentOS/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/tags/CentOS/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"数学公式中的希腊字母读音","slug":"数学公式中的希腊字母读音","date":"2020-05-04T04:02:58.247Z","updated":"2020-09-05T12:39:53.643Z","comments":true,"path":"2020/05/04/数学公式中的希腊字母读音/","link":"","permalink":"http://yoursite.com/2020/05/04/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%B8%8C%E8%85%8A%E5%AD%97%E6%AF%8D%E8%AF%BB%E9%9F%B3/","excerpt":"数学公式中的希腊字母读音。","text":"数学公式中的希腊字母读音。 α：阿尔法 β：背他 γ：伽玛 Δ：德尔塔 ε：艾普西龙 η：依他 θ：西他 λ：拦姆达 μ：缪 ξ：克赛（克西） π：派 ρ：柔 σ：西格玛 φ：fai ω：殴米伽","categories":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"公式","slug":"公式","permalink":"http://yoursite.com/tags/%E5%85%AC%E5%BC%8F/"}]},{"title":"以太坊搭建私链","slug":"以太坊搭建私链","date":"2020-04-30T04:00:47.472Z","updated":"2020-09-05T12:37:04.073Z","comments":true,"path":"2020/04/30/以太坊搭建私链/","link":"","permalink":"http://yoursite.com/2020/04/30/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%90%AD%E5%BB%BA%E7%A7%81%E9%93%BE/","excerpt":"创建Dapp的第一步，搭建私链。","text":"创建Dapp的第一步，搭建私链。 一、环境准备go、cmake以及geth资源下载，提取码：qfe2 1.1 安装go 下载源码，上传至opt/module，解压。以下所有的文件解压后的文件夹，全部修改文件夹名为：包名+版本号 1tar -xvf go1.14.6.linux-amd64.tar.gz 设置环境变量，vim /etc/profile。 1234export GOROOT&#x3D;&#x2F;opt&#x2F;module&#x2F;go1.14.6#GOPATH需要自己新建一个文件夹export GOPATH&#x3D;&#x2F;root&#x2F;Code&#x2F;goexport PATH&#x3D;$PATH:&#x2F;opt&#x2F;module&#x2F;go1.14.6&#x2F;bin 执行source /etc/profile更新环境变量配置。 验证安装: 1go version 1.2 安装cmake 下载源码，上传至opt/module，解压 1tar -xvf cmake-3.15.2.tar.gz 设置环境变量，vim /etc/profile。 1export PATH&#x3D;$PATH:&#x2F;opt&#x2F;module&#x2F;cmake3.15.2&#x2F;bin 执行source /etc/profile更新环境变量配置。 安装gcc程序包 1yum install -y gcc gcc-c++ make automake 进入cmke目录执行以下下命令，完成编译。这几步时间有些长，耐心等待。 1234cd cmake3.15.2./bootstrapgmakegmake install 验证安装 1cmake --version 二、安装geth 下载源码，上传至opt/module，解压。 1tar zxvf go-ethereum-1.9.19.tar.gz 设置环境变量，vim /etc/profile。 1export PATH&#x3D;$PATH:&#x2F;opt&#x2F;module&#x2F;go-ethereum1.9.19&#x2F;build&#x2F;bin 执行source /etc/profile更新环境变量配置。 执行以下命令来编译源码 123go env -w GOPROXY=https://goproxy.cncd go-ethereum1.9.19make all 验证安装 1geth version 三、geth操作1、启动节点同步，（搭建私链不需要）1234geth --datadir . --syncmode fast//一快速模式同步区块，只会下载每个区块同和区块体，不会执行验证所有的交易。geth --testnet --datadit . --syncmode fast 2、开发者模式开发者模式：是为方便以太坊开发者在以太坊平台上开发测试所建立的一种模式。开发者模式相比自己搭建私链有很多好处，比如不需要链码，会预留一个拥有巨额ETH的账户，账户之间转账不需要先解锁，采用POA证明方式，自动进行挖矿且有交易才挖矿（不会一直挖矿消耗资源）。总体是类似与ganache的模拟链。 开发者模式的开启方法： 123mkdir devChaincd devChaingeth --datadir . --dev --nodiscover --networkid 1234 --rpc --rpccorsdomain \"*\" --rpcaddr 192.168.2.151 --rpcport 8545 console --allow-insecure-unlock 2&gt;output.log 参数说明： –datadir：以太坊私链的文件目录。 –dev：开启开发者模式。 –nodiscover：不发现同一个networkid其他节点。 –networkid：以太坊的网路id，可以自己任意取值。 –rpc：开启rpc接口，Dapp就是通过rpc方式来与以太坊进行交互。 –rpcaddr：rpc的ip，默认是localhost，这里填写的是CentOS本机的IP。如在本地运行虚拟机，网络IP最好不要用DHCP模式获取，固定IP的设置方法。如是远程服务器，填服务器的ip即可。 –rpcport：rpc端口，需要将防火墙中的8545端口开放，开放方法：防火墙设置 console：开启console，能够和geth交互。 –allow-insecure-unlock：没有这个参数,无法解锁账户。 2&gt;output.log：将输出重定向到文件中。 output.log中会包括私链开启以及挖矿的详细信息，执行以下命令可以查看私链运行状态： 1tail -f output.log 3、搭建私链新建mychain文件夹，创建genesis.json chainId：以太坊的链的id，可以自己随便取值，但是需要注意搭建私链时，这个值不能与以太坊主网或者是测试网的chainId相同。以太坊chainId查询 123456789101112131415161718192021222324252627&#123; \"config\": &#123; \"chainId\": 666, \"homesteadBlock\": 0, \"eip150Block\": 0, \"eip150Hash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"eip155Block\": 0, \"eip158Block\": 0, \"byzantiumBlock\": 0, \"constantinopleBlock\": 0, \"petersburgBlock\": 0, \"istanbulBlock\": 0, \"ethash\": &#123;&#125; &#125;, \"nonce\": \"0x0\", \"timestamp\": \"0x5ddf8f3e\", \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0x47b760\", \"difficulty\": \"0x00002\", \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": &#123; &#125; &#125;, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\"&#125; 在mychain文件夹下，初始化链json 1geth --datadir . init genesis.json 启动私链，networkid和rpcaddr的设置方法同开发者模式。查看输出日志output.log同上。 1geth --datadir . --nodiscover --networkid 1234 --rpc --rpccorsdomain \"*\" --rpcaddr 192.168.2.151 --rpcport 8545 console --allow-insecure-unlock 2&gt;output.log 注意：搭建私链后一定要进行以下测试，看是否能够正常发起交易。 4、私链console验证交易的步骤是： 创建两个账户 执行挖矿 执行转账 查看recipient余额 查看块数量 1eth.blockNumber 创建账户： 1personal.newAccount(\"password\") 执行挖矿：(这一步会生成DAG，花费时间会很长，需要耐心等待到100%) 如果出块速度很慢，可以设置链码的difficulty参数，或者提高虚拟机的内存和核心数量，然后执行miner.start(2)来执行多线程挖矿。 1miner.start(1) 获取账户： 12my=eth.accounts[0]other=eth.accounts[1] 解锁账户（发起交易前需要对sender解锁）： 12personal.unlockAccount(my)//随后输入密码：1234 查看余额： 1eth.getBalance(other) 发起转账： 1eth.sendTransaction(&#123;from:my, to:other, value:10000&#125;) 如果没有挖矿 12txpool.status//查看本地交易池中有没有待确认的交易eth.getBlock(\"pending\",true).transactions//查看当前待确认的交易 查看交易信息： 1eth.getTransaction(\"交易哈希\") 通过区块号查看区块信息： 1eth.getBlock(0)","categories":[{"name":"以太坊","slug":"以太坊","permalink":"http://yoursite.com/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"私链搭建","slug":"私链搭建","permalink":"http://yoursite.com/tags/%E7%A7%81%E9%93%BE%E6%90%AD%E5%BB%BA/"}]},{"title":"水龙头合约创建发布","slug":"水龙头合约","date":"2020-04-30T03:59:14.175Z","updated":"2020-09-05T12:39:21.505Z","comments":true,"path":"2020/04/30/水龙头合约/","link":"","permalink":"http://yoursite.com/2020/04/30/%E6%B0%B4%E9%BE%99%E5%A4%B4%E5%90%88%E7%BA%A6/","excerpt":"创建发布水龙头合约。","text":"创建发布水龙头合约。 重要网站： 以太坊链上查询：etherscan.io 以太坊测试链上查询：ropsten.etherscan.io 线上IDE：remix.ethereum.org 合约代码123456789pragma solidity ^0.4.17;contract Faucet&#123; function withdraw(uint amount) public&#123; require (amount &lt;&#x3D; 1000000000000000000); msg.sender.transfer(1000000000000000000); &#125; function() public payable &#123;&#125;&#125; 第一步：编译 QQ截图20200302090418 第二步：部署 QQ截图20200302090449 第三步：查看合约地址，并给地址转账 QQ截图20200302091244 第四步：调用水龙头函数 QQ截图20200302090704 第五步：查看转账 QQ截图20200302090743","categories":[{"name":"以太坊","slug":"以太坊","permalink":"http://yoursite.com/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"}],"tags":[{"name":"水龙头合约","slug":"水龙头合约","permalink":"http://yoursite.com/tags/%E6%B0%B4%E9%BE%99%E5%A4%B4%E5%90%88%E7%BA%A6/"}]},{"title":"Python MongoDB","slug":"pymongo笔记","date":"2020-04-30T03:48:31.229Z","updated":"2020-09-05T12:38:33.207Z","comments":true,"path":"2020/04/30/pymongo笔记/","link":"","permalink":"http://yoursite.com/2020/04/30/pymongo%E7%AC%94%E8%AE%B0/","excerpt":"依靠pymongo包来对mongoDB数据库进行操作","text":"依靠pymongo包来对mongoDB数据库进行操作 一、pymongo安装首先通过pip list或者通过import pymongo，查看自己装没装pymongo。 1pip install pymongo 出错提示版本匹配有问题。 通过Anaconda中安装pymongo环境，失败。 重新更新pip版本 1python -m pip install --upgrade pip 更新成功后，再pip install pymongo，成功！！ 二、pymongo基本操作1.创建数据库连接名[&quot;库名&quot;] 1234import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\") #创建名字为runoob的数据库mydb = myclient[\"runoob\"] 2.获取数据库列表连接名.list_database_names() 123456import pymongomyclient = pymongo.MongoClient('mongodb://localhost:27017/')#获取数据库列表dblist = myclient.list_database_names()if \"runoobdb\" in dblist: print(\"数据库已存在！\") 3.创建集合（表）库名[&quot;集合名&quot;] 12345import pymongomyclient = pymongo.MongoClient('mongodb://localhost:27017/')mydb = myclient[\"runoob\"]#创建名字为sites的集合mycol = mydb[\"sites\"] 4.获取集合列表库名.list_collection_names() 1234567import pymongomyclient = pymongo.MongoClient('mongodb://localhost:27017/')mydb = myclient['runoobdb']#获取集合列表collist = mydb.list_collection_names()if \"sites\" in collist: # 判断 sites 集合是否存在 print(\"集合已存在！\") 5.插入文档5.1 插入单个文档集合名.inset_one() 该方法返回 InsertOneResult 对象，该对象包含 inserted_id 属性，它是插入文档的 id 值。 123456789import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]mydict = &#123;\"name\":\"RUNOOB\",\"alexa\":\"10000\",\"url\":\"https://www.runoob.com\"&#125;x = mycol.insert_one(mydict) print(x)print(x.inserted_id) 5.2 插入多个文档集合名.inset_many() 1234567891011121314151617import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]mylist = [ &#123; \"name\": \"Taobao\", \"alexa\": \"100\", \"url\": \"https://www.taobao.com\" &#125;, &#123; \"name\": \"QQ\", \"alexa\": \"101\", \"url\": \"https://www.qq.com\" &#125;, &#123; \"name\": \"Facebook\", \"alexa\": \"10\", \"url\": \"https://www.facebook.com\" &#125;, &#123; \"name\": \"知乎\", \"alexa\": \"103\", \"url\": \"https://www.zhihu.com\" &#125;, &#123; \"name\": \"Github\", \"alexa\": \"109\", \"url\": \"https://www.github.com\" &#125;]x = mycol.insert_many(mylist)# 输出插入的所有文档对应的 _id 值print(x.inserted_ids) 5.2 插入多个文档（指定_id）1234567891011121314151617import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"site2\"]mylist = [ &#123; \"_id\": 1, \"name\": \"RUNOOB\", \"cn_name\": \"菜鸟教程\"&#125;, &#123; \"_id\": 2, \"name\": \"Google\", \"address\": \"Google 搜索\"&#125;, &#123; \"_id\": 3, \"name\": \"Facebook\", \"address\": \"脸书\"&#125;, &#123; \"_id\": 4, \"name\": \"Taobao\", \"address\": \"淘宝\"&#125;, &#123; \"_id\": 5, \"name\": \"Zhihu\", \"address\": \"知乎\"&#125;]x = mycol.insert_many(mylist)# 输出插入的所有文档对应的 _id 值print(x.inserted_ids) 6.查询文档6.1 查询单个文档集合名.find_one() 123456789import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]x = mycol.find_one()#无条件，即为第一条数据print(x) 6.2 查询所有文档集合名.find() 12345678910import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017\")mydb = myclient[\"runoob\"]mycol = mydb[\"sites\"]for x in mycol.find() print(x) for y in mycol.find(&#123;&#125;,&#123;\"_id\":0,\"title\":1&#125;) print(y) ==除了 _id ，你不能在一个对象中同时指定 0 和 1（如{ “name”: 1, “alexa”: 0 }），如果你设置了一个字段为 0，则其他都为 1，反之亦然。== 6.3 查询指定条件文档1234567891011import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]#查询名字为RUNOOB的文档myquery = &#123; \"name\": \"RUNOOB\" &#125; mydoc = mycol.find(myquery)for x in mydoc: print(x) 6.4 高级查询基本和mongoDB中写法相同。 123456789101112import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]myquery = &#123; \"name\": &#123; \"$gt\": \"H\" &#125; &#125; mydoc = mycol.find(myquery) for x in mydoc: print(x) 6.5 使用正则表达式匹配字符串123456789101112import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]#\"$regex\"表示使用正则表达式，\"^R\"表示首字母为Rmyquery = &#123; \"name\": &#123; \"$regex\": \"^R\" &#125; &#125;mydoc = mycol.find(myquery)for x in mydoc: print(x) 6.6 返回指定记录数集合名.find().limit(num) 1234567891011import pymongo myclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]myresult = mycol.find().limit(3)# 输出结果for x in myresult: print(x) 7.修改文档7.1 修改单个文档集合名.update_one() 12345678910111213import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]myquery = &#123; \"alexa\": \"10000\" &#125;newvalues = &#123; \"$set\": &#123; \"alexa\": \"12345\" &#125; &#125;mycol.update_one(myquery, newvalues)# 输出修改后的 \"sites\" 集合for x in mycol.find(): print(x) 7.1 修改多个文档集合名.update_many() 123456789101112import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]myquery = &#123; \"alexa\": &#123; \"$reget\":\"^F\"&#125; &#125;newvalues = &#123; \"$set\": &#123; \"alexa\": \"123\" &#125; &#125;x = mycol.update_many(myquery, newvalues)# 输出修改匹配的数量print(x.modified_count, \"文档已修改\") 8.排序文档集合名.find().sort() 12345678import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"]#\"-1\"为降序排列mydoc = mycol.find().sort(\"alexa\",-1)for x in mydoc: print(x) 9.删除数据9.1 删除单个文档集合名.delete_one() 1234567891011import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] myquery = &#123; \"name\": \"Taobao\" &#125;mycol.delete_one(myquery)# 删除后输出for x in mycol.find(): print(x) 9.2 删除多个文档集合名.delete_many() 12345678910import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] myquery = &#123; \"name\": &#123;\"$reget\":\"^F\"&#125; &#125;x = mycol.delete_many(myquery)# 删除后输出print(x.deleted_count, \"个文档已删除\") 9.3 删除所有文档集合名.delete_many() 123456789import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] #传入空的查询对象x = mycol.delete_many(&#123;&#125;)# 删除后输出print(x.deleted_count, \"个文档已删除\") 9.4 删除集合集合名.drop() 123456import pymongomyclient = pymongo.MongoClient(\"mongodb://localhost:27017/\")mydb = myclient[\"runoobdb\"]mycol = mydb[\"sites\"] mycol.drop()","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/categories/MongoDB/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"MongoDB学习笔记","slug":"mongdb","date":"2020-04-30T03:48:16.857Z","updated":"2020-09-05T12:38:05.313Z","comments":true,"path":"2020/04/30/mongdb/","link":"","permalink":"http://yoursite.com/2020/04/30/mongdb/","excerpt":"在菜鸟教程中学了MongoDB，做此笔记以记录。","text":"在菜鸟教程中学了MongoDB，做此笔记以记录。 一、MongoDB安装1.下载官方下载地址：https://www.mongodb.com/download-center/community 快速下载地址：http://dl.mongodb.org/dl/win32/x86_64 2.安装点击custom可以修改安装目录，另外取消勾选Install MongoDB Compass选项。此为图形界面管理工具。 3.配置 将bin文件夹配置到PATH的环境变量中。 在data文件夹下手动创建db和log 在log文件夹下创建mongodb.log 在安装文件夹下新建mongo.config 文件中写入 12345678910111213141516171819#数据文件，路径必须是你自己的电脑的对应路径dbpath&#x3D;D:\\Program Files\\MongoDB\\Server\\4.2\\data\\db#日志文件 logpath&#x3D;D:\\Program Files\\MongoDB\\Server\\4.2\\data\\log\\mongodb.log#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件logappend&#x3D;true #启用日志文件，默认启用journal&#x3D;true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet&#x3D;true #端口号 默认为27017port&#x3D;27017 点击mongod.exe，如果闪一下退出，说明安装正常。进入测试地址localhost:27017。 进入bin文件夹，使用如下命令： 1mongod --config D:\\Program Files\\MongoDB\\Server\\4.2\\mongo.config --install --serviceName &quot;MongoDB&quot; 右键我的电脑，管理查看mongoDB服务是否自动开启。 Warning: 原因：新版本的MongDB增加了安全性设计，推荐用户创建使用数据库时进行验证。如果用户想建立简单连接，则会提示警示信息。 解决方案：创建管理员并设置密码 12345678&gt;use admin&gt;db.createUser( &#123; user: &quot;admin&quot;, &#x2F;&#x2F;用户名 pwd: &quot;passwd&quot;, &#x2F;&#x2F;密码 roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ] &#x2F;&#x2F;设置权限 &#125;) 二、Robo 3T安装1.下载官方下载地址：https://robomongo.org/download 2.建立连接点击Create， QQ截图20200224202820 修改连接名，save QQ截图20200224202902 三、基本概念1.概念 MongoDB有着与您熟知的‘数据库’（database，对于Oracle就是‘schema’）一样的概念。在一个MongoDB的实例中您有若干个数据库或者一个也没有，不过这里的每一个数据库都是高层次的容器，用来储存其他的所有数据。 一个数据库可以有若干‘集合’（collection），或者一个也没有。集合和传统概念中的‘表’有着足够多的共同点，所以您大可认为这两者是一样的东西。 集合由若干‘文档’（document）组成，也可以为空。类似的，可以认为这里的文档就是‘行’。 文档又由一个或者更多个‘域’（field）组成，您猜的没错，域就像是‘列’。 ‘索引’（index）在MongoDB中的意义就如同索引在RDBMS中一样。 ‘游标’（cursor）和以上5个概念不同，它很重要但是却常常被忽略，有鉴于此我认为应该进行专门讨论。关于游标有一点很重要，就是每当向MongoDB索要数据时，它总是返回一个游标。基于游标我们可以作诸如计数或是直接跳过之类的操作，而不需要真正去读数据。 小结一下，MongoDB由‘数据库’组成，数据库由‘集合’组成，集合由‘文档’组成。‘域’组成了文档，集合可以被‘索引’，从而提高了查找和排序的性能。最后，我们从MongoDB读取数据的时候是通过‘游标’进行的，除非需要，游标不会真正去作读的操作。 2._id生成规则MongoDB的文档必须有一个_id键。 目的是为了确认在集合里的每个文档都能被唯一标识。 ObjectId 是 _id 的默认类型。 ObjectId 采用12字节的存储空间，每个字节两位16进制数字，是一个24位的字符串。 12位生成规则： [0,1,2,3] [4,5,6] [7,8] [9,10,11] 时间戳 |机器码 |PID |计数器 前四字节是时间戳，可以提供秒级别的唯一性。 接下来三字节是所在主机的唯一标识符，通常是机器主机名的散列值。 接下来两字节是产生ObjectId的PID，确保同一台机器上并发产生的ObjectId是唯一的。 前九字节保证了同一秒钟不同机器的不同进程产生的ObjectId时唯一的。 最后三字节是自增计数器，确保相同进程同一秒钟产生的ObjectId是唯一的。 四、语法格式1.创建数据库1use DATABASE_NAME 如果数据库不存在，则创建。否则切换到指定数据库 2.查看所有数据库（无数据则不显示）1show dbs 3.删库（先use，再drop）12use runoobdb.dropDatabase() 4.创建集合（表）12db.createCollection(name, options)&#x2F;&#x2F;注意Colle“C”大写db.createCollection(&quot;mycol&quot;,&#123;capped:true,autoIndexId:true,size:6142800,max:10000&#125;) name：要创建的集合名字 options：可选参数 字段 类型 描述 capped 布尔 （可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。 当该值为 true 时，必须指定 size 参数。 autoIndexId 布尔 （可选）如为 true，自动在 _id 字段创建索引。默认为 false。 size 数值 （可选）为固定集合指定一个最大值，以千字节计（KB）。 如果 capped 为 true，也需要指定该字段。 max 数值 （可选）指定固定集合中包含文档的最大数量。 在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。 12 5.查看集合1show collections 6.删除集合1db.COLLECTION_NAME.drop() 7.插入文档（一条记录）1234567891011db.COLLECTION_NAME.insert(document)db.collection.insertOne(&#123;&quot;a&quot;: 3&#125;)db.collection.insertMany([&#123;&quot;b&quot;: 3&#125;, &#123;&#39;c&#39;: 4&#125;])&#x2F;&#x2F;例子，该集合不在该数据库中，MongoDB会自动创建该集合并插入文档。db.col.insert(&#123;title: &#39;MongoDB 教程&#39;, description: &#39;MongoDB 是一个 Nosql 数据库&#39;, by: &#39;菜鸟教程&#39;, url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;, tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;], likes: 100&#125;) 也可以将数据定义为一个变量,然后插入： 12345678document&#x3D;(&#123;title: &#39;MongoDB 教程&#39;, description: &#39;MongoDB 是一个 Nosql 数据库&#39;, by: &#39;菜鸟教程&#39;, url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;, tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;], likes: 100&#125;);db.col.insert(document) 8.查看已插入文档12db.COLLECTION_NAME.find()db.COLLECTION_NAME.find().pretty()&#x2F;&#x2F;格式优化 9.更新文档12345678910db.collection.update( &lt;query&gt;, &lt;update&gt;, &#123; upsert: &lt;boolean&gt;, multi: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;)db.col.update(&#123;&#39;title&#39;:&#39;MongoDB 教程&#39;&#125;,&#123;$set:&#123;&#39;title&#39;:&#39;MongoDB&#39;&#125;&#125;,&#123;multi:true&#125;) query : update的查询条件，类似sql update查询内where后面的。 update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的 upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern :可选，抛出异常的级别。 save() 方法通过传入的文档来替换已有文档。语法格式如下： 123456db.collection.save( &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125;) document : 文档数据。 writeConcern :可选，抛出异常的级别。 123456789101112db.col.save(&#123; &quot;_id&quot; : ObjectId(&quot;56064f89ade2f21f36b03136&quot;), &quot;title&quot; : &quot;MongoDB&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;, &quot;by&quot; : &quot;Runoob&quot;, &quot;url&quot; : &quot;http:&#x2F;&#x2F;www.runoob.com&quot;, &quot;tags&quot; : [ &quot;mongodb&quot;, &quot;NoSQL&quot; ], &quot;likes&quot; : 110&#125;) 10.删除文档12345678db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;)db.col.remove(&#123;&#39;title&#39;:&#39;MongoDB 教程&#39;&#125;) query :（可选）删除的文档的条件。 justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。 writeConcern :（可选）抛出异常的级别。 11.查询文档1db.collection.find(query, projection) query ：可选，使用查询操作符指定查询条件 projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略） 如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下： 1db.col.find().pretty() 11.1 ==比较操作符== 操作 格式 范例 RDBMS中的类似语句 等于 {:} db.col.find({&quot;by&quot;:&quot;菜鸟教程&quot;}).pretty() where by = &#39;菜鸟教程&#39; 小于 {:{$lt:}} db.col.find({&quot;likes&quot;:{$lt:50}}).pretty() where likes &lt; 50 小于等于 {:{$lte:}} db.col.find({&quot;likes&quot;:{$lte:50}}).pretty() where likes &lt;= 50 大于 {:{$gt:}} db.col.find({&quot;likes&quot;:{$gt:50}}).pretty() where likes &gt; 50 大于等于 {:{$gte:}} db.col.find({&quot;likes&quot;:{$gte:50}}).pretty() where likes &gt;= 50 不等于 {:{$ne:}} db.col.find({&quot;likes&quot;:{$ne:50}}).pretty() where likes != 50 11.2 AND比较条件多条件间以逗号隔开 1db.col.find(&#123;key1:value1, key2:value2&#125;).pretty() 11.3 OR比较条件123456789db.col.find( &#123; $or: [ &#123;key1: value1&#125;, &#123;key2:value2&#125; ] &#125;).pretty()&#x2F;&#x2F;举例子db.col.find(&#123;$or:[&#123;&quot;by&quot;:&quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty() 11.4 AND 和 OR 联合使用1db.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;菜鸟教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB 教程&quot;&#125;]&#125;).pretty() 11.5 使用 (&lt;) 和 (&gt;) 查询1db.col.find(&#123;likes : &#123;$lt :200, $gt : 100&#125;&#125;) 11.6 $type操作符1db.col.find(&#123;&quot;title&quot; : &#123;$type : &#39;string&#39;&#125;&#125;) 12.Limit与Skip方法1db.COLLECTION_NAME.find().limit(NUMBER) ==db.col.find({},{“title”:1,_id:0}).limit(2)== 1db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) 13.排序sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。 1db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;) 14.创建索引12db.collection.createIndex(keys, options)db.values.createIndex(&#123;open: 1, close: 1&#125;, &#123;background: true&#125;) Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。 createIndex() 接收可选参数，可选参数列表如下： Parameter Type Description background Boolean 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。 unique Boolean 建立的索引是否唯一。指定为true创建唯一索引。默认值为false. name string 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。 dropDups Boolean 3.0+版本已废弃。在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false. sparse Boolean 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false. expireAfterSeconds integer 指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。 v index version 索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。 weights document 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。 default_language string 对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语 language_override string 对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language. 15.聚合1db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION) 表达式 描述 实例 $sum 计算总和。 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}]) $avg 计算平均值 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}]) $min 获取集合中所有文档对应值得最小值。 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}]) $max 获取集合中所有文档对应值得最大值。 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}]) $push 在结果文档中插入值到一个数组中。 db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}]) $addToSet 在结果文档中插入值到一个数组中，但不创建副本。 db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}]) $first 根据资源文档的排序获取第一个文档数据。 db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}]) $last 根据资源文档的排序获取最后一个文档数据 db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}]) 16.管道管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数。 MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。 表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。 这里我们介绍一下聚合框架中常用的几个操作： $project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。 $match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。 $limit：用来限制MongoDB聚合管道返回的文档数。 $skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。 $unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。 $group：将集合中的文档分组，可用于统计结果。 $sort：将输入文档排序后输出。 $geoNear：输出接近某一地理位置的有序文档。 123456db.article.aggregate( &#123; $project : &#123; title : 1 , author : 1 , &#125;&#125; ); 这样的话结果中就只还有_id,tilte和author三个字段了，默认情况下_id字段是被包含的，如果要想不包含_id话可以这样: 123456db.article.aggregate( &#123; $project : &#123; _id : 0 , title : 1 , author : 1 &#125;&#125;); 五、维护1.副本集？2.分片集？3.备份(mongodump)与恢复(mongorestore)备份mongodump 12mongodump -h dbhost -d dbname -o dbdirectorymongodump -h 127.0.0.1:27017 -d TestBase -o D:\\data\\home\\momgodump -h： MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017 -d： 需要备份的数据库实例，例如：test -o： 备份的数据存放位置，例如：c:\\data\\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 恢复mongorestore 12mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;mongorestore -h 127.0.0.1:27017 -d TestBase --dir D:\\data\\home\\momgodump\\TestBase –host &lt;:port&gt;, -h &lt;:port&gt;： MongoDB所在服务器地址，默认为： localhost:27017 –db , -d ： 需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2 –drop： 恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！ ： mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\\data\\dump\\test。 你不能同时指定 和 –dir 选项，–dir也可以设置备份目录。 –dir： 指定备份的目录 你不能同时指定 和 –dir 选项。 4.监控mongostat会间隔固定时间获取mongodb的当前运行状态，并输出。 1mongostat mongotop提供了一个方法，用来跟踪一个MongoDB的实例，查看哪些大量的时间花费在读取和写入数据。 mongotop提供每个集合的水平的统计数据。默认情况下，mongotop返回值的每一秒。 1mongotop 5.Mongodb to Json1mongoexport -h 连接地址 --port 端口 --authenticationDatabase admin -u 用户名 -p 密码 -d 数据库名字 -c 集合名 -o D:\\tx.json --authenticationDatabase admin不加这个参数会出现错误。","categories":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/categories/MongoDB/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"Typora+PicGo+七牛云 个人博客方案","slug":"Typora+PicGo+七牛云 个人博客方案","date":"2020-04-30T03:23:35.425Z","updated":"2020-09-05T12:38:29.336Z","comments":true,"path":"2020/04/30/Typora+PicGo+七牛云 个人博客方案/","link":"","permalink":"http://yoursite.com/2020/04/30/Typora+PicGo+%E4%B8%83%E7%89%9B%E4%BA%91%20%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%96%B9%E6%A1%88/","excerpt":"选择Typora+PicGo+七牛云这一套个人博客方案，简化自己创建博客过程。","text":"选择Typora+PicGo+七牛云这一套个人博客方案，简化自己创建博客过程。 注意：七牛云的域名只能用一个月，所以最好拥有一个备案的域名。不然一个月后的图床域名会被回收，之前上传的图片无法下载，只能通过官方工具来下载。至于如何通过官方工具来下载图片，后期再更新吧。总之，这是个悲伤的故事。 1. PicGo的下载安装下载地址：https://molunerfinn.com/PicGo/ 找到图床设置，七牛图床。 QQ截图20200430105256 查看自己需要的配置项。 QQ截图20200430105451 需要填写的配置项： AccessKey：接入公钥。 SecretKey：自己的私钥。 存储空间名：七牛云上设置的存储空间名。 访问地址：七牛云上空间的外链访问地址。 存储区域：创建空间时，选择的存储区域，从z0到z1，依次对应：华东、华北、华南、北美、东南亚。 2. 七牛云图床创建七牛云官网：https://www.qiniu.com/ 注册选择个人用户，登录并个人身份认证。 点击自己的头像，选择秘钥管理。 QQ截图20200430110237 这样就可以看到自己的AccessKey和SercetKey了。复制粘贴到PicGo的配置中。 在左边侧边栏中找到对象存储。 QQ截图20200430110522 找到空间管理，选择新建空间。 QQ截图20200430110657 在新建空间时可以设置响应的空间名，存储区域。 存储区域选择一个举例自己位置近的即可。注意：填在PicGo的存储区域，是相应的区域代码：z0-z4 访问控制选择公开。 这样就可以在PicGo中填入，空间名和存储区域。 QQ截图20200430110926 现在就差一个访问地址没有填了。 这个可以在空间管理，找到自己刚创建的空间，选择后面的概览，进入概览后选择文件管理，这样就看到自己的外链域名了。（注意：这个地址不可复制） QQ截图20200430111715 将地址输入PicGo的配置中，在指定存储路径中添加img/。 这样PicGo就配置好了。 3. Typora配置选择文件-&gt;偏好设置-&gt;图像。按照图中配置，配置完验证图片上传选项即可。 QQ截图20200430112103","categories":[{"name":"个人博客","slug":"个人博客","permalink":"http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"图床应用","slug":"图床应用","permalink":"http://yoursite.com/tags/%E5%9B%BE%E5%BA%8A%E5%BA%94%E7%94%A8/"}]},{"title":"功能测试","slug":"test","date":"2020-01-03T03:41:23.267Z","updated":"2020-09-05T12:39:04.168Z","comments":true,"path":"2020/01/03/test/","link":"","permalink":"http://yoursite.com/2020/01/03/test/","excerpt":"测试一些博客的功能","text":"测试一些博客的功能","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"Numpy学习笔记","slug":"Numpy","date":"2020-01-01T07:49:09.931Z","updated":"2020-09-05T12:39:39.090Z","comments":true,"path":"2020/01/01/Numpy/","link":"","permalink":"http://yoursite.com/2020/01/01/Numpy/","excerpt":"学习Numpy的基本应用","text":"学习Numpy的基本应用 首先需要导入Numpy包 1from numpy import * 一、ndarray数组1、数组的生成1&gt;&gt;&gt;a = array([0,1,2,3]) 可以与C语言一样用索引来定位数组元素，如： 1&gt;&gt;&gt;a[0] = 5 也可以将数组改为二维数组 1234&gt;&gt;&gt;a.shape = 2,2&gt;&gt;&gt;print(a) [[5 1] [2 3]] 特例： 12345678910111213141516&gt;&gt;&gt;b = zeros((2,3),dtype=int)#生成2行3列的0填充数组 [[0 0 0] [0 0 0]]&gt;&gt;&gt;a = ones((3,2),dtype=int) * 5 [[5 5] [5 5] [5 5]]&gt;&gt;&gt;b.fill(-4.8)#向数组中填充元素，填充元素会转化为数组原数据类型 [[-4 -4 -4] [-4 -4 -4]]&gt;&gt;&gt;a = arange(0,80,10)#start到end间隔是10左闭右开 array([ 0, 10, 20, 30, 40, 50, 60, 70])&gt;&gt;&gt;a = identity(3,dtype=int)#生成单位矩阵 array([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]]) 2、数组的类型 复数数组 1234&gt;&gt;&gt;a = array([1 + 1j, 2, 3, 4])&gt;&gt;&gt;a.real#实部&gt;&gt;&gt;a.imag#虚部&gt;&gt;&gt;a.conj()#查看共轭 类型转换： 12&gt;&gt;&gt;asarray(a, dtype=float64)#不会修改原数组的值,但转换与原数组类型相同时返回引用&gt;&gt;&gt;a.astype(float64)#无论何时返回复制 3、数组的属性1234&gt;&gt;&gt;a.size#数组的大小&gt;&gt;&gt;a.shape#数组的形状&gt;&gt;&gt;a.nbytes#数组元素所占空间&gt;&gt;&gt;a.ndim#数组维数 4、数组索引切片 花式索引：与切片不同花式索引返回的是对象的一个复制不是引用。 12&gt;&gt;&gt;indices = [1, 2, -3]&gt;&gt;&gt;y = a[indices] 还可以用bool值 12&gt;&gt;&gt;mask = array([0,1,1,0,0,1,0,0],dtype=bool)&gt;&gt;&gt;a[mask] mask数组可以用布尔表达式生成 1234&gt;&gt;&gt;from numpy.random import rand&gt;&gt;&gt;a = rand(10)#生成[0,1)之间的10个随机数&gt;&gt;&gt;mask = a &gt; 0.5&gt;&gt;&gt;a[mask] 二维花式索引： 123456&gt;&gt;&gt;a[(0,1,2,3,4), (1,2,3,4,5)]#行标列标一一对应，a[0,1],a[1,2]...5个数&gt;&gt;&gt;a[3:, [0,2,5]]#第四行后，1,3,6列&gt;&gt;&gt;mask = array([1,0,1,0,0,1],dtype=bool)&gt;&gt;&gt;a[mask, 2]#依然可以用mask索引&gt;&gt;&gt;y = a[:3]#返回前3行 where语句： 12345&gt;&gt;&gt;loc = where(a &gt; 10)&gt;&gt;&gt;a[loc] (array([0, 0, 1, 1], dtype=int64), array([1, 3, 2, 3], dtype=int64)) #如同二维花式索引，行列坐标一一对应&gt;&gt;&gt;rows, cols = where(a&gt;10) 5、数组的方法求和： 123456&gt;&gt;&gt;a = array([[1,2,3],[4,5,6]])a.sum(axis=1)&gt;&gt;&gt;sum(a)&gt;&gt;&gt;sum(a,axis=0)#或者a.sum(axis=0)沿着第一维度增方向求和，得到行向量 array([5, 7, 9])&gt;&gt;&gt;sum(a,axis=1)#或者a.sum(axis=1)沿着第而维度增方向求和，得到类向量 array([ 6, 15]) 求积： 12&gt;&gt;&gt;a.prod()&gt;&gt;&gt;prod(a, axis=0) 最大值最小值： 1234&gt;&gt;&gt;a.max()#全局最大&gt;&gt;&gt;a.max(axis=-1)&gt;&gt;&gt;a.min()#全局最小&gt;&gt;&gt;a.min(axis=0)#沿着第一维度最小，得到行向量 最大值最小值位置： 12&gt;&gt;&gt;a.argmin()&gt;&gt;&gt;a.argmax(axis=0) 均值： 123&gt;&gt;&gt;a.mean()&gt;&gt;&gt;a.mean(axis=-1)&gt;&gt;&gt;average(a, axis = 0, weights=[1,2])#可以算加权平均 标准差： 1&gt;&gt;&gt;a.std(axis=1) 方差： 1&gt;&gt;&gt;a.var(axis=1) 将数值限制在某个范围内： 1234&gt;&gt;&gt;a = array([[1, 2, 3],[4, 5, 6]])&gt;&gt;&gt;a.clip(3,5) array([[3, 3, 3], [4, 5, 5]]) 计算最大值与最小值之差： 1&gt;&gt;&gt;a.ptp(axis=1) 近似方法： 1&gt;&gt;&gt;a.round(decimals=1)#近似到以为小数 6、数组排序分为函数和方法注意：其他三种不改变原数组，只有data.sort()方法会改变 1234&gt;&gt;&gt;sort(weights)#函数&gt;&gt;&gt;data.sort()#方法 注意注意&gt;&gt;&gt;argsort(weights)#函数&gt;&gt;&gt;data.argsort()#方法 对二维数组默认相当于对每一行的元素进行排序 12345678910111213&gt;&gt;&gt;a = array([ [.2, .1, .5], [.4, .8, .3], [.9, .6, .7] ])&gt;&gt;&gt;sort(a) array([[ 0.1, 0.2, 0.5], [ 0.3, 0.4, 0.8], [ 0.6, 0.7, 0.9]])&gt;&gt;&gt;sort(a, axis = 0) array([[ 0.2, 0.1, 0.3], [ 0.4, 0.6, 0.5], [ 0.9, 0.8, 0.7]]) 7、数组形状修改形状 123&gt;&gt;&gt;a = arange(6)&gt;&gt;&gt;a.shape = 2,3&gt;&gt;&gt;b = a.reshape(3,2)#返回一个新数组 数组连接 12345678910x = array([ [0,1,2], [10,11,12] ])y = array([ [50,51,52], [60,61,62] ])z = concatenate((x,y))#第一维度连接z = concatenate((x,y), axis=1)#第二维度连接 降维 123a = array([[0,1], [2,3]])b = a.flatten()#降为1维数组 8、数组对角线123&gt;&gt;&gt;a.diagonal()&gt;&gt;&gt;a.diagonal(offset=1)#对角线右移&gt;&gt;&gt;a.diagonal(offset=-1)#对角线左移","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"Nunpy","slug":"Nunpy","permalink":"http://yoursite.com/tags/Nunpy/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-01-01T04:19:20.007Z","updated":"2020-01-02T12:05:53.615Z","comments":true,"path":"2020/01/01/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/01/hello-world/","excerpt":"Welcome HelloWorld","text":"Welcome HelloWorld Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/categories/leetcode/"},{"name":"bug","slug":"bug","permalink":"http://yoursite.com/categories/bug/"},{"name":"以太坊","slug":"以太坊","permalink":"http://yoursite.com/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"面经","slug":"面经","permalink":"http://yoursite.com/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/categories/hadoop/"},{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/categories/CentOS/"},{"name":"scrapy","slug":"scrapy","permalink":"http://yoursite.com/categories/scrapy/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/categories/%E6%95%B0%E5%AD%A6/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/categories/MongoDB/"},{"name":"个人博客","slug":"个人博客","permalink":"http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"二分法","slug":"二分法","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"归并排序","slug":"归并排序","permalink":"http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"递归","slug":"递归","permalink":"http://yoursite.com/tags/%E9%80%92%E5%BD%92/"},{"name":"快慢指针","slug":"快慢指针","permalink":"http://yoursite.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"哨兵","slug":"哨兵","permalink":"http://yoursite.com/tags/%E5%93%A8%E5%85%B5/"},{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"},{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"tomcat","slug":"tomcat","permalink":"http://yoursite.com/tags/tomcat/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"},{"name":"以太坊","slug":"以太坊","permalink":"http://yoursite.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"},{"name":"inputData","slug":"inputData","permalink":"http://yoursite.com/tags/inputData/"},{"name":"欧拉回路","slug":"欧拉回路","permalink":"http://yoursite.com/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"},{"name":"欧拉通路","slug":"欧拉通路","permalink":"http://yoursite.com/tags/%E6%AC%A7%E6%8B%89%E9%80%9A%E8%B7%AF/"},{"name":"Hierholzer算法","slug":"Hierholzer算法","permalink":"http://yoursite.com/tags/Hierholzer%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"bfs","slug":"bfs","permalink":"http://yoursite.com/tags/bfs/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"},{"name":"暴力","slug":"暴力","permalink":"http://yoursite.com/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"manacher","slug":"manacher","permalink":"http://yoursite.com/tags/manacher/"},{"name":"分治","slug":"分治","permalink":"http://yoursite.com/tags/%E5%88%86%E6%B2%BB/"},{"name":"Dapp","slug":"Dapp","permalink":"http://yoursite.com/tags/Dapp/"},{"name":"truffle","slug":"truffle","permalink":"http://yoursite.com/tags/truffle/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://yoursite.com/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://yoursite.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"逆波兰","slug":"逆波兰","permalink":"http://yoursite.com/tags/%E9%80%86%E6%B3%A2%E5%85%B0/"},{"name":"栈","slug":"栈","permalink":"http://yoursite.com/tags/%E6%A0%88/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"},{"name":"字节跳动","slug":"字节跳动","permalink":"http://yoursite.com/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"hadoop","slug":"hadoop","permalink":"http://yoursite.com/tags/hadoop/"},{"name":"wordcount","slug":"wordcount","permalink":"http://yoursite.com/tags/wordcount/"},{"name":"CentOS","slug":"CentOS","permalink":"http://yoursite.com/tags/CentOS/"},{"name":"scrapy","slug":"scrapy","permalink":"http://yoursite.com/tags/scrapy/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"JDK","slug":"JDK","permalink":"http://yoursite.com/tags/JDK/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"公式","slug":"公式","permalink":"http://yoursite.com/tags/%E5%85%AC%E5%BC%8F/"},{"name":"私链搭建","slug":"私链搭建","permalink":"http://yoursite.com/tags/%E7%A7%81%E9%93%BE%E6%90%AD%E5%BB%BA/"},{"name":"水龙头合约","slug":"水龙头合约","permalink":"http://yoursite.com/tags/%E6%B0%B4%E9%BE%99%E5%A4%B4%E5%90%88%E7%BA%A6/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"},{"name":"图床应用","slug":"图床应用","permalink":"http://yoursite.com/tags/%E5%9B%BE%E5%BA%8A%E5%BA%94%E7%94%A8/"},{"name":"测试","slug":"测试","permalink":"http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Nunpy","slug":"Nunpy","permalink":"http://yoursite.com/tags/Nunpy/"}]}